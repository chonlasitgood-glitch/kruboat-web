<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Spatial Math</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Sarabun:wght@300;400;700&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body {
            background-color: #000;
            color: white;
            font-family: 'Sarabun', sans-serif;
            overflow: hidden;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #webcam, #output_canvas, #three_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        #three_canvas {
            transform: none; 
            pointer-events: none;
        }
        .ui-overlay {
            position: absolute;
            z-index: 10;
        }
        .tech-font {
            font-family: 'Orbitron', sans-serif;
        }
        
        /* Sidebar Styling */
        #level-menu {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(0, 255, 255, 0.2);
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 20;
            pointer-events: auto; /* ‡πÉ‡∏´‡πâ‡∏Å‡∏î‡πÑ‡∏î‡πâ */
            padding-bottom: 80px;
        }
        #level-menu.open {
            transform: translateX(0);
        }
        
        /* Scrollbar */
        #level-menu::-webkit-scrollbar {
            width: 6px;
        }
        #level-menu::-webkit-scrollbar-thumb {
            background: #06b6d4; 
            border-radius: 3px;
        }

        .level-card {
            transition: all 0.2s;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .level-card:hover {
            background: rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.5);
        }
        .level-card.active {
            background: rgba(6, 182, 212, 0.3);
            border-color: #06b6d4;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
        }
    </style>
</head>
<body>

    <div id="container">
        <!-- 1. Webcam & Canvases -->
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
        <canvas id="three_canvas"></canvas>

        <!-- 2. UI Header -->
        <div class="ui-overlay top-4 left-4 bg-black/60 p-5 rounded-xl border border-cyan-500/50 backdrop-blur-md shadow-lg shadow-cyan-500/20 pointer-events-none">
            <h1 class="text-2xl font-bold text-cyan-300 flex items-center gap-2 tech-font">
                <i data-lucide="cuboid"></i> SPATIAL MATH
            </h1>
            <p class="text-base text-white mt-2 font-bold" id="question-text">‡πÇ‡∏à‡∏ó‡∏¢‡πå: ‡∏°‡∏µ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏µ‡πà‡πÉ‡∏ö?</p>
            <p class="text-sm text-gray-300 mt-1">üí° ‡∏ä‡∏π‡∏ô‡∏¥‡πâ‡∏ß‡∏ä‡∏µ‡πâ ‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏∑‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á</p>
            <div id="status" class="mt-3 text-xs flex items-center gap-2 text-yellow-400">
                <div class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                Loading AI...
            </div>
            <!-- Hand Indicator -->
            <div id="hand-indicator" class="mt-1 text-xs text-cyan-200 opacity-80">
                Wait for hand...
            </div>
        </div>
        
        <!-- 3. Sidebar Toggle Button -->
        <div class="ui-overlay top-4 right-4 pointer-events-auto">
            <button id="toggleMenu" class="p-3 bg-cyan-900/80 hover:bg-cyan-700 text-white rounded-lg border border-cyan-500/50 transition shadow-[0_0_15px_rgba(6,182,212,0.3)]">
                <i data-lucide="menu"></i>
            </button>
        </div>

        <!-- 4. Level Menu Sidebar -->
        <div id="level-menu" class="open">
            <div class="p-4 sticky top-0 bg-black/90 backdrop-blur-md border-b border-gray-800 z-10 flex justify-between items-center">
                <h2 class="text-lg font-bold text-cyan-400 tech-font">LEVEL SELECT</h2>
                <button id="closeMenu" class="text-gray-400 hover:text-white"><i data-lucide="x"></i></button>
            </div>
            <div id="level-list" class="p-3 space-y-3">
                <!-- Level Cards will be injected here -->
            </div>
        </div>

        <!-- 5. Bottom Action Button -->
        <div class="ui-overlay bottom-8 left-1/2 transform -translate-x-1/2 pointer-events-auto">
            <button id="toggleCam" class="px-8 py-3 bg-gradient-to-r from-blue-600 to-indigo-600 rounded-full hover:scale-105 transition shadow-[0_0_20px_rgba(79,70,229,0.5)] flex items-center gap-2 text-lg font-bold text-white">
                <i data-lucide="play-circle"></i> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏ó‡πÄ‡∏£‡∏µ‡∏¢‡∏ô
            </button>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        lucide.createIcons();

        // --- Data: Level Configuration ---
        const levels = [
            {
                id: 1,
                name: "Beginner I",
                difficulty: "Easy",
                color: "text-green-400",
                blocks: [
                    {x:0, y:0, z:0}, {x:1, y:0, z:0}, {x:0, y:1, z:0}
                ]
            },
            {
                id: 2,
                name: "Beginner II",
                difficulty: "Easy",
                color: "text-green-400",
                blocks: [
                    {x:0, y:0, z:0}, {x:1, y:0, z:0}, {x:2, y:0, z:0},
                    {x:1, y:1, z:0}
                ]
            },
            {
                id: 3,
                name: "Intermediate I",
                difficulty: "Medium",
                color: "text-yellow-400",
                blocks: [
                    {x:0, y:0, z:0}, {x:1, y:0, z:0}, 
                    {x:0, y:0, z:-1},
                    {x:0, y:1, z:0}
                ]
            },
            {
                id: 4,
                name: "Intermediate II",
                difficulty: "Medium",
                color: "text-yellow-400",
                blocks: [
                    {x:0, y:0, z:0}, {x:1, y:0, z:0}, 
                    {x:0, y:1, z:0}, {x:1, y:1, z:-1},
                    {x:2, y:0, z:0}
                ]
            },
            {
                id: 5,
                name: "Advanced I",
                difficulty: "Hard",
                color: "text-orange-400",
                blocks: [
                    {x:0, y:0, z:0}, {x:1, y:0, z:0}, {x:0, y:0, z:-1}, {x:1, y:0, z:-1},
                    {x:0.5, y:1, z:-0.5} 
                ]
            },
            {
                id: 6,
                name: "Advanced II",
                difficulty: "Very Hard",
                color: "text-red-400",
                blocks: [
                    {x:0, y:0, z:0}, 
                    {x:0, y:1, z:0},
                    {x:0, y:1, z:-1},
                    {x:1, y:1, z:-1},
                    {x:1, y:0, z:-1},
                    {x:1, y:0, z:0}
                ]
            },
            {
                id: 7,
                name: "Expert Cube",
                difficulty: "Expert",
                color: "text-purple-400",
                blocks: [
                    {x:0, y:0, z:0}, {x:1, y:0, z:0}, {x:0, y:1, z:0}, {x:1, y:1, z:0},
                    {x:0, y:0, z:-1}, {x:1, y:0, z:-1}, {x:0, y:1, z:-1}, {x:1, y:1, z:-1}
                ]
            }
        ];

        let currentLevelIndex = 0;

        // --- Elements ---
        const video = document.getElementById('webcam');
        const canvas2D = document.getElementById('output_canvas');
        const ctx2D = canvas2D.getContext('2d');
        const canvas3D = document.getElementById('three_canvas');
        const statusEl = document.getElementById('status');
        const handIndicator = document.getElementById('hand-indicator');
        const btnCam = document.getElementById('toggleCam');
        
        // UI Menu Elements
        const menu = document.getElementById('level-menu');
        const btnToggleMenu = document.getElementById('toggleMenu');
        const btnCloseMenu = document.getElementById('closeMenu');
        const levelList = document.getElementById('level-list');
        const questionText = document.getElementById('question-text');

        let handLandmarker;
        let webcamRunning = false;
        let cubeMesh, scene, camera, renderer;

        // --- UI Logic: Build Menu ---
        function initMenu() {
            levelList.innerHTML = '';
            levels.forEach((lvl, index) => {
                const card = document.createElement('div');
                card.className = `level-card bg-gray-900 p-3 rounded-lg cursor-pointer flex items-center gap-3 ${index === currentLevelIndex ? 'active' : ''}`;
                card.onclick = () => loadLevel(index);

                // Create Mini Canvas for Preview
                const cvs = document.createElement('canvas');
                cvs.width = 60;
                cvs.height = 60;
                cvs.className = "rounded bg-gray-800 border border-gray-700";
                drawThumbnail(cvs, lvl.blocks);

                const info = document.createElement('div');
                info.innerHTML = `
                    <div class="text-sm font-bold text-white">${lvl.name}</div>
                    <div class="text-xs ${lvl.color}">${lvl.difficulty} (${lvl.blocks.length} Blocks)</div>
                `;

                card.appendChild(cvs);
                card.appendChild(info);
                levelList.appendChild(card);
            });
        }

        function drawThumbnail(canvas, blocks) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const scale = 12; // size of block in px
            const cx = w/2;
            const cy = h/2 + 10;

            // Simple isometric-ish projection for preview
            ctx.clearRect(0,0,w,h);
            ctx.fillStyle = "#06b6d4";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;

            // Sort blocks by depth (z) and height (y) to draw back-to-front painter's algo
            const sorted = [...blocks].sort((a,b) => (a.z - b.z) || (a.y - b.y) || (a.x - b.x));

            sorted.forEach(b => {
                // Iso projection formula
                const isoX = (b.x - b.z) * scale * 0.8;
                const isoY = (b.x + b.z) * scale * 0.4 - (b.y * scale * 1.2);
                
                const px = cx + isoX;
                const py = cy + isoY;

                ctx.fillRect(px - scale/2, py - scale/2, scale, scale);
                ctx.strokeRect(px - scale/2, py - scale/2, scale, scale);
            });
        }

        btnToggleMenu.onclick = () => menu.classList.add('open');
        btnCloseMenu.onclick = () => menu.classList.remove('open');

        // --- Three.js Setup ---
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Create Group Container
            cubeMesh = new THREE.Group();
            scene.add(cubeMesh);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x0088ff, 0.8);
            backLight.position.set(-5, -5, -10);
            scene.add(backLight);

            // Load Initial Level
            loadLevel(0);
        }

        // --- Block Builder Logic ---
        function createBlock(x, y, z) {
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            
            // Material: Orange Tech
            const material = new THREE.MeshPhongMaterial({
                color: 0xff8800, emissive: 0xaa4400, emissiveIntensity: 0.2,
                transparent: true, opacity: 0.9, shininess: 80,
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Outline
            const outlineMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
            const outline = new THREE.Mesh(geometry, outlineMat);
            outline.scale.set(1.05, 1.05, 1.05);
            mesh.add(outline);

            // Wireframe
            const wireGeo = new THREE.EdgesGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const wire = new THREE.LineSegments(wireGeo, wireMat);
            mesh.add(wire);

            mesh.position.set(x, y, z);
            return mesh;
        }

        window.loadLevel = function(index) {
            currentLevelIndex = index;
            const lvl = levels[index];

            // 1. Clear old blocks
            while(cubeMesh.children.length > 0){ 
                cubeMesh.remove(cubeMesh.children[0]); 
            }

            // 2. Add new blocks
            // Calculate center to offset
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity, minZ=Infinity, maxZ=-Infinity;
            lvl.blocks.forEach(b => {
                minX = Math.min(minX, b.x); maxX = Math.max(maxX, b.x);
                minY = Math.min(minY, b.y); maxY = Math.max(maxY, b.y);
                minZ = Math.min(minZ, b.z); maxZ = Math.max(maxZ, b.z);
            });
            
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;
            const cz = (minZ + maxZ) / 2;

            lvl.blocks.forEach(pos => {
                // Offset by center so the group pivot is in the middle
                cubeMesh.add(createBlock(pos.x - cx, pos.y - cy, pos.z - cz));
            });

            // 3. Update UI Active State
            document.querySelectorAll('.level-card').forEach((el, i) => {
                if(i === index) el.classList.add('active');
                else el.classList.remove('active');
            });
            
            // Update Question
            questionText.innerText = `‡πÇ‡∏à‡∏ó‡∏¢‡πå ${lvl.name}: ‡∏°‡∏µ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏µ‡πà‡πÉ‡∏ö?`;
        }

        // --- AI Setup ---
        async function setupAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                statusEl.innerHTML = `<span class="text-green-400">‚óè AI ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</span>`;
                statusEl.className = "mt-3 text-xs flex items-center gap-2 text-green-400 font-bold";
            } catch (err) {
                console.error(err);
                statusEl.textContent = "Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î AI ‡πÑ‡∏î‡πâ";
            }
        }

        // --- Loop & Tracking ---
        let lastVideoTime = -1;
        const lerpFactor = 0.2; 
        let targetPos = new THREE.Vector3();
        let targetScale = new THREE.Vector3(1, 1, 1);
        let targetQuaternion = new THREE.Quaternion();

        async function predictLoop() {
            if (!webcamRunning) return;

            // Resize Logic
            if (canvas3D.width !== window.innerWidth || canvas3D.height !== window.innerHeight) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                canvas2D.width = window.innerWidth;
                canvas2D.height = window.innerHeight;
            }

            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                
                try {
                    const startTimeMs = performance.now();
                    const results = handLandmarker.detectForVideo(video, startTimeMs);

                    ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);

                    if (results.landmarks && results.landmarks.length > 0) {
                        const landmarks = results.landmarks[0];
                        
                        // --- Fix 1: Safer Handedness Check ---
                        let isRightHand = true; // Default
                        if (results.handedness?.[0]?.[0]) {
                            const catName = results.handedness[0][0].categoryName;
                            isRightHand = (catName === "Right");
                            handIndicator.innerText = `Hand: ${catName} (Face Palm Mode)`;
                        } else {
                            handIndicator.innerText = `Hand: Unknown (Default Right)`;
                        }

                        const indexTip = landmarks[8];
                        const indexMCP = landmarks[5];

                        // Calculations
                        const vFingerY = new THREE.Vector3(
                            (1-indexTip.x) - (1-indexMCP.x), 
                            -(indexTip.y - indexMCP.y),      
                            -(indexTip.z - indexMCP.z)
                        ).normalize();

                        const screenX = (1 - indexTip.x) * 2 - 1; 
                        const screenY = -(indexTip.y * 2 - 1);
                        
                        const wrist = landmarks[0];
                        const middleMCP = landmarks[9];
                        const palmSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                        const zDepth = (palmSize * 15) - 4; 

                        const vector = new THREE.Vector3(screenX, screenY, 0.5);
                        vector.unproject(camera);
                        const dir = vector.sub(camera.position).normalize();
                        const distance = Math.abs((camera.position.z - zDepth) / dir.z);
                        const basePos = camera.position.clone().add(dir.multiplyScalar(distance));
                        
                        const offsetAmount = 1.2; 
                        const offsetVector = vFingerY.clone().multiplyScalar(offsetAmount);
                        targetPos.copy(basePos).add(offsetVector);

                        targetScale.set(0.7, 0.7, 0.7); 

                        const pinkyMCP = landmarks[17];
                        const vPalmX = new THREE.Vector3(
                            (1-pinkyMCP.x) - (1-indexMCP.x), 
                            -(pinkyMCP.y - indexMCP.y),      
                            -(pinkyMCP.z - indexMCP.z)
                        ).normalize();

                        // Calculate Forward Vector (vZ) based on Cross Product
                        let vZ = new THREE.Vector3().crossVectors(vPalmX, vFingerY).normalize();

                        if (isRightHand) {
                            vZ.negate();
                        }

                        const vX = new THREE.Vector3().crossVectors(vFingerY, vZ).normalize();

                        const rotationMatrix = new THREE.Matrix4();
                        rotationMatrix.makeBasis(vX, vFingerY, vZ);
                        targetQuaternion.setFromRotationMatrix(rotationMatrix);

                        // --- Fix 2: Rotate 70 degrees Left ---
                        const yRotation = new THREE.Quaternion();
                        // 70 degrees to radians = 70 * (PI / 180)
                        yRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 70 * (Math.PI / 180));
                        targetQuaternion.multiply(yRotation);

                        cubeMesh.visible = true;

                    } else {
                        targetScale.set(0, 0, 0); // Hide if no hand
                        handIndicator.innerText = "Wait for hand...";
                    }

                    // Render updates (Moved inside try block to ensure it runs if no error)
                    cubeMesh.position.lerp(targetPos, lerpFactor);
                    cubeMesh.scale.lerp(targetScale, lerpFactor);
                    cubeMesh.quaternion.slerp(targetQuaternion, lerpFactor); 
                    renderer.render(scene, camera);

                } catch (error) {
                    console.error("AI Error:", error);
                    // Keep running despite error
                }
            }
            requestAnimationFrame(predictLoop);
        }

        // --- Init ---
        initMenu();
        initThreeJS();
        setupAI();

        btnCam.addEventListener('click', () => {
            if (!handLandmarker) return;
            if (webcamRunning) {
                webcamRunning = false;
                const stream = video.srcObject;
                if(stream) stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                btnCam.innerHTML = `<i data-lucide="play-circle"></i> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏ó‡πÄ‡∏£‡∏µ‡∏¢‡∏ô`;
                btnCam.classList.replace('from-red-600', 'from-blue-600');
                btnCam.classList.replace('to-pink-600', 'to-indigo-600');
                cubeMesh.visible = false;
                renderer.render(scene, camera);
            } else {
                webcamRunning = true;
                btnCam.innerHTML = `<i data-lucide="pause-circle"></i> ‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß`;
                btnCam.classList.replace('from-blue-600', 'from-red-600');
                btnCam.classList.replace('to-indigo-600', 'to-pink-600');
                navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictLoop);
                });
            }
        });

    </script>
</body>
</html>