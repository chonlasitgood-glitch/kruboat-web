<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Cyber Cube</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Three.js (สำหรับ 3D) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body {
            background-color: #000;
            color: white;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden; /* ป้องกัน Scrollbar */
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        /* Video และ Canvas จะซ้อนทับกัน */
        #webcam, #output_canvas, #three_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* กลับด้านกระจกเงา */
        }
        /* Canvas 3D ไม่ต้องกลับด้านที่ CSS เพราะเราจะจัดการตำแหน่งใน JS */
        #three_canvas {
            transform: none; 
            pointer-events: none; /* ให้คลิกทะลุได้ */
        }
        .ui-overlay {
            position: absolute;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="container">
        <!-- 1. กล้อง Webcam -->
        <video id="webcam" autoplay playsinline></video>
        
        <!-- 2. Canvas สำหรับวาดเส้นมือ (Debug) -->
        <canvas id="output_canvas"></canvas>
        
        <!-- 3. Canvas สำหรับ 3D Model (Three.js) -->
        <canvas id="three_canvas"></canvas>

        <!-- UI -->
        <div class="ui-overlay top-4 left-4 bg-black/50 p-4 rounded-xl border border-cyan-500/30 backdrop-blur-md">
            <h1 class="text-2xl font-bold text-cyan-400 flex items-center gap-2">
                <i data-lucide="box"></i> AR Cyber Cube
            </h1>
            <p class="text-xs text-gray-300 mt-1">จีบนิ้วโป้งและนิ้วชี้เพื่อควบคุมกล่อง</p>
            <div id="status" class="mt-2 text-xs flex items-center gap-2 text-yellow-400">
                <div class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                Loading AI...
            </div>
        </div>
        
        <div class="ui-overlay bottom-8 left-1/2 transform -translate-x-1/2">
            <button id="toggleCam" class="pointer-events-auto px-6 py-2 bg-gradient-to-r from-cyan-600 to-blue-600 rounded-full hover:scale-105 transition shadow-[0_0_15px_rgba(6,182,212,0.5)] flex items-center gap-2">
                <i data-lucide="power"></i> เปิดกล้อง / เริ่มระบบ
            </button>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        lucide.createIcons();

        // --- Configuration ---
        const video = document.getElementById('webcam');
        const canvas2D = document.getElementById('output_canvas');
        const ctx2D = canvas2D.getContext('2d');
        const canvas3D = document.getElementById('three_canvas');
        const statusEl = document.getElementById('status');
        const btnCam = document.getElementById('toggleCam');

        let handLandmarker;
        let webcamRunning = false;
        let cubeMesh, scene, camera, renderer;

        // --- 1. Three.js Setup (The Cube) ---
        function initThreeJS() {
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // --- สร้างกล่อง (Box Geometry) ---
            
            // 1. Core Cube (เนื้อใน) - ปรับเป็นวัสดุที่ทึบแสงขึ้นและสีเข้ม เพื่อให้ตัดกับฉากหลัง
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({
                color: 0x001133,       // สีน้ำเงินเข้มเกือบดำ (ช่วยบังฉากหลังวิดีโอ)
                emissive: 0x0044ff,    // เรืองแสงสีน้ำเงิน
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.8,          // ปรับความทึบเป็น 80% ตามที่ขอ
                shininess: 100,
                side: THREE.DoubleSide
            });
            cubeMesh = new THREE.Mesh(geometry, material);

            // 2. Thick Outline (สร้างขอบหนา) - เทคนิคสร้าง Mesh ซ้อนแล้วกลับด้าน (BackSide)
            const outlineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,        // สีขอบฟ้าสว่าง (Cyan)
                side: THREE.BackSide    // วาดเฉพาะด้านใน ทำให้เมื่อขยายขนาดจะกลายเป็นขอบ
            });
            const outlineMesh = new THREE.Mesh(geometry, outlineMaterial);
            outlineMesh.scale.set(1.06, 1.06, 1.06); // ขยายให้ใหญ่กว่าตัวหลักเล็กน้อยเพื่อเป็นขอบ
            cubeMesh.add(outlineMesh);

            // 3. Wireframe (เส้นขอบคมๆ สีขาว) - ซ้อนทับไปอีกชั้นเพื่อความคมชัด
            const wireGeo = new THREE.EdgesGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            cubeMesh.add(wireframe);

            // 4. Inner Core (แกนกลางหมุนได้) - สีชมพูตัดกัน
            const coreGeo = new THREE.IcosahedronGeometry(0.3, 0);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
            const coreMesh = new THREE.Mesh(coreGeo, coreMat);
            cubeMesh.add(coreMesh);
            cubeMesh.userData = { core: coreMesh }; // เก็บไว้หมุนเล่น

            scene.add(cubeMesh);

            // --- Lighting (แสง) ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            const blueLight = new THREE.PointLight(0x0088ff, 2);
            blueLight.position.set(-5, -5, 2);
            scene.add(blueLight);
        }
        initThreeJS();

        // --- 2. MediaPipe Setup ---
        async function setupAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                statusEl.innerHTML = `<span class="text-green-400">● AI Ready</span>`;
                statusEl.className = "mt-2 text-xs flex items-center gap-2 text-green-400";

            } catch (err) {
                console.error(err);
                statusEl.textContent = "Error loading AI. Try disabling Hardware Acceleration.";
            }
        }
        setupAI();

        // --- 3. Webcam & Loop ---
        btnCam.addEventListener('click', () => {
            if (!handLandmarker) return;
            if (webcamRunning) {
                stopCam();
            } else {
                startCam();
            }
        });

        function startCam() {
            webcamRunning = true;
            btnCam.innerHTML = `<i data-lucide="stop-circle"></i> ปิดกล้อง`;
            btnCam.classList.replace('from-cyan-600', 'from-red-600');
            btnCam.classList.replace('to-blue-600', 'to-red-500');

            navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictLoop);
            });
        }

        function stopCam() {
            webcamRunning = false;
            const stream = video.srcObject;
            if(stream) stream.getTracks().forEach(track => track.stop());
            video.srcObject = null;
            
            btnCam.innerHTML = `<i data-lucide="power"></i> เปิดกล้อง / เริ่มระบบ`;
            btnCam.classList.replace('from-red-600', 'from-cyan-600');
            btnCam.classList.replace('to-red-500', 'to-blue-600');
            
            cubeMesh.visible = false;
            renderer.render(scene, camera);
        }

        // --- 4. Main Logic Loop ---
        let lastVideoTime = -1;
        
        // ตัวแปรสำหรับ Lerp (Smoothing)
        const lerpFactor = 0.2; // ค่ายิ่งน้อยยิ่งนุ่มแต่ดีเลย์ (0.1 - 0.3 กำลังดี)
        let targetPos = new THREE.Vector3();
        let targetScale = new THREE.Vector3(1, 1, 1);
        let targetQuaternion = new THREE.Quaternion();

        async function predictLoop() {
            if (!webcamRunning) return;

            // Resize Logic
            if (canvas3D.width !== window.innerWidth || canvas3D.height !== window.innerHeight) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                canvas2D.width = window.innerWidth;
                canvas2D.height = window.innerHeight;
            }

            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const startTimeMs = performance.now();
                const results = handLandmarker.detectForVideo(video, startTimeMs);

                // Clear Debug Canvas
                ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);

                if (results.landmarks && results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0];
                    
                    // --- Logic การวางตำแหน่ง: กึ่งกลางระหว่างนิ้วโป้งและชี้ ---
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    
                    // หาจุดกึ่งกลาง (Midpoint)
                    const midX = (thumbTip.x + indexTip.x) / 2;
                    const midY = (thumbTip.y + indexTip.y) / 2;
                    
                    // แปลงเป็น World Coordinates
                    // Mirror X for display
                    const screenX = (1 - midX) * 2 - 1; 
                    const screenY = -(midY * 2 - 1);
                    
                    // คำนวณความลึก (Z) จากขนาดฝ่ามือ (Wrist to Middle MCP)
                    // เพื่อให้รู้สึกว่ามือใกล้-ไกล มีผลต่อตำแหน่ง 3D
                    const wrist = landmarks[0];
                    const middleMCP = landmarks[9];
                    const palmSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                    // สูตร Z-depth heuristic
                    const zDepth = (palmSize * 15) - 4; 

                    // Project from 2D screen to 3D world at calculated Z
                    const vector = new THREE.Vector3(screenX, screenY, 0.5);
                    vector.unproject(camera);
                    const dir = vector.sub(camera.position).normalize();
                    const distance = Math.abs((camera.position.z - zDepth) / dir.z); // Project ไปที่ระนาบ Z
                    const newPos = camera.position.clone().add(dir.multiplyScalar(distance));
                    
                    targetPos.copy(newPos);


                    // --- Logic ขนาด (Scale): ระยะห่างนิ้วโป้ง-ชี้ ---
                    const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                    // คูณค่าคงที่เพื่อให้ขนาดเหมาะสม
                    const scaleVal = Math.max(0.1, pinchDist * 8); 
                    targetScale.set(scaleVal, scaleVal, scaleVal);


                    // --- Logic การหมุน (Rotation): อิงตามระนาบมือ ---
                    // สร้าง Basis Vectors ของมือ
                    // Y-axis: Wrist -> Middle MCP (ทิศทางที่มือชี้ไป)
                    const vY = new THREE.Vector3(
                        (1-middleMCP.x) - (1-wrist.x), // Flip X
                        -(middleMCP.y - wrist.y),      // Flip Y
                        -(middleMCP.z - wrist.z)       // Z
                    ).normalize();

                    // X-axis: Index MCP -> Pinky MCP (ระนาบความกว้างมือ)
                    const indexMCP = landmarks[5];
                    const pinkyMCP = landmarks[17];
                    const vX = new THREE.Vector3(
                        (1-pinkyMCP.x) - (1-indexMCP.x), // Flip X
                        -(pinkyMCP.y - indexMCP.y),      // Flip Y
                        -(pinkyMCP.z - indexMCP.z)
                    ).normalize();

                    // Z-axis: Cross product (Normal ของฝ่ามือ)
                    const vZ = new THREE.Vector3().crossVectors(vX, vY).normalize();

                    // Re-orthogonalize X to make sure it's 90 deg to Y and Z
                    vX.crossVectors(vY, vZ).normalize();

                    // สร้าง Rotation Matrix จาก Basis Vectors
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeBasis(vX, vY, vZ);
                    targetQuaternion.setFromRotationMatrix(rotationMatrix);

                    cubeMesh.visible = true;

                    // วาดจุด Debug บนนิ้วโป้งและชี้
                    // drawPinchLine(thumbTip, indexTip);

                } else {
                    // ถ้าไม่เจอมือ ให้ค่อยๆ หดหายไป
                    targetScale.set(0, 0, 0);
                }

                // --- Apply Smoothing (Lerp) ---
                // ค่อยๆ ขยับจากค่าปัจจุบันไปหาค่าเป้าหมาย
                cubeMesh.position.lerp(targetPos, lerpFactor);
                cubeMesh.scale.lerp(targetScale, lerpFactor);
                cubeMesh.quaternion.slerp(targetQuaternion, lerpFactor); // slerp สำหรับการหมุน

                // Animation ลูกเล่น: หมุนแกนกลาง (Core) เล่นๆ
                if (cubeMesh.userData.core) {
                    cubeMesh.userData.core.rotation.x += 0.02;
                    cubeMesh.userData.core.rotation.y += 0.03;
                }

                renderer.render(scene, camera);
            }

            requestAnimationFrame(predictLoop);
        }

        // Helper: วาดเส้นระหว่างนิ้ว (ถ้าต้องการ)
        function drawPinchLine(p1, p2) {
            const w = canvas2D.width;
            const h = canvas2D.height;
            ctx2D.strokeStyle = "#00ffff";
            ctx2D.lineWidth = 2;
            ctx2D.beginPath();
            ctx2D.moveTo((1-p1.x)*w, p1.y*h);
            ctx2D.lineTo((1-p2.x)*w, p2.y*h);
            ctx2D.stroke();
            
            // Draw points
            ctx2D.fillStyle = "#ffff00";
            ctx2D.beginPath(); ctx2D.arc((1-p1.x)*w, p1.y*h, 5, 0, 2*Math.PI); ctx2D.fill();
            ctx2D.beginPath(); ctx2D.arc((1-p2.x)*w, p2.y*h, 5, 0, 2*Math.PI); ctx2D.fill();
        }
        
    </script>
</body>
</html>