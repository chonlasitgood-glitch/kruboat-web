<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Hand Control</title>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        /* 3D Scene Container */
        #scene-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* Camera Preview Container (Top-Left) */
        #preview-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            height: 240px;
            z-index: 10;
            border: 2px solid #0ff;
            background: rgba(0, 20, 20, 0.8);
            box-shadow: 0 0 15px #0ff;
            border-radius: 8px;
            overflow: hidden;
        }

        /* Hide the raw video element, we draw on canvas */
        .input_video {
            display: none;
        }

        /* Canvas for MediaPipe Overlay */
        .output_canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror effect */
        }

        /* UI Overlay for Instructions */
        #ui-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0ff;
            z-index: 5;
            pointer-events: none;
            text-shadow: 0 0 5px #0ff;
        }

        h1 { margin: 0; font-size: 24px; text-transform: uppercase; }
        p { margin: 5px 0; font-size: 14px; color: #fff; opacity: 0.8; }
        
        .status-badge {
            display: inline-block;
            padding: 5px 10px;
            margin-top: 10px;
            background: #222;
            border: 1px solid #f0f;
            color: #f0f;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 0 5px #f0f;
        }

        /* Loading Spinner CSS (Optional purely CSS fallback) */
        .loader {
            display: none; /* Controlled by JS canvas drawing instead */
        }
    </style>
</head>
<body>

    <!-- 3D Scene -->
    <div id="scene-container"></div>

    <!-- Camera Preview & Hand Tracking -->
    <div id="preview-container">
        <video class="input_video"></video>
        <canvas class="output_canvas" width="320" height="240"></canvas>
    </div>

    <!-- Instructions -->
    <div id="ui-overlay">
        <h1>Cyberpunk Hand Control</h1>
        <p>1. กำมือค้างไว้ (1 วินาที) เพื่อจับวัตถุ</p>
        <p>2. แบมือ เพื่อปล่อย</p>
        <p>3. ชูนิ้วชี้ เพื่อหมุน (Pointing)</p>
        <div id="status-text" class="status-badge">SYSTEM READY</div>
    </div>

    <script>
        // --- 1. THREE.JS SETUP (The 3D World) ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('scene-container').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        const magentaLight = new THREE.PointLight(0xff00ff, 1, 100);
        magentaLight.position.set(-5, -5, 5);
        scene.add(magentaLight);

        // The Cyberpunk Cube
        const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x000000, 
            roughness: 0.1,
            metalness: 0.9,
            emissive: 0x001133,
            emissiveIntensity: 0.5
        });
        const cube = new THREE.Mesh(geometry, material);
        
        // Wireframe edges for that "Tron" look
        const edges = new THREE.EdgesGeometry(geometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
        const wireframe = new THREE.LineSegments(edges, lineMaterial);
        cube.add(wireframe); // Add wireframe to cube so they move together
        
        scene.add(cube);

        // Grid Floor
        const gridHelper = new THREE.GridHelper(50, 50, 0xff00ff, 0x222222);
        gridHelper.position.y = -3;
        scene.add(gridHelper);

        // Helper to calculate visible width/height at a given Z depth
        function getVisibleDimensions(depth, camera) {
            const vFOV = camera.fov * Math.PI / 180; // convert vertical fov to radians
            const distance = camera.position.z - depth; // distance from camera to object
            const height = 2 * Math.tan(vFOV / 2) * distance;
            const width = height * camera.aspect;
            return { width, height };
        }

        // --- 2. LOGIC VARIABLES ---
        let handX = 0, handY = 0; // Normalized 0-1
        let isHandDetected = false;
        let gestureState = 'IDLE'; // IDLE, FIST, POINTING, OPEN
        let interactionState = 'IDLE'; // IDLE, CHARGING, GRABBED, ROTATING
        let grabStartTime = 0;
        const GRAB_DELAY = 1000; // 1 second
        
        // Smoothing variables
        let targetRotationZ = 0;
        let targetRotationX = 0;
        
        const statusElement = document.getElementById('status-text');

        // --- 3. MEDIAPIPE HANDS SETUP ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            // Clear canvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                isHandDetected = true;

                // Draw Landmarks
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#ff00ff', lineWidth: 1, radius: 2});

                // --- GESTURE RECOGNITION ---
                detectGesture(landmarks);
                
                // --- UPDATE CURSOR POSITION ---
                const pointer = landmarks[9]; // Middle finger knuckle
                handX = 1 - pointer.x; // Mirror X
                handY = pointer.y;

                // Handle Interaction Logic
                handleInteraction(landmarks);

            } else {
                // --- FIX: FORCE RESET IF HAND IS LOST ---
                isHandDetected = false;
                resetInteraction();
            }
            canvasCtx.restore();
        }
        
        function resetInteraction() {
            if(interactionState !== 'IDLE') {
                interactionState = 'IDLE';
                gestureState = 'IDLE';
                updateStatus('SYSTEM READY');
                wireframe.material.color.setHex(0x00ffff);
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();

        // --- 4. GESTURE & INTERACTION LOGIC ---

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function detectGesture(landmarks) {
            // FIX: Use Hand Scale (Wrist to Middle Finger MCP) for scale-invariant thresholds
            const wrist = landmarks[0];
            const middleMCP = landmarks[9];
            const handScale = distance(wrist, middleMCP); 
            
            // Helper to check if finger is open (Tip further from wrist than PIP from wrist)
            const isFingerOpen = (tipIdx, pipIdx) => {
                return distance(landmarks[tipIdx], wrist) > distance(landmarks[pipIdx], wrist) + (handScale * 0.1);
            };

            const isIndexOpen = isFingerOpen(8, 6);
            const isMiddleOpen = isFingerOpen(12, 10);
            const isRingOpen = isFingerOpen(16, 14);
            const isPinkyOpen = isFingerOpen(20, 18);
            
            // GESTURE LOGIC REFINED
            
            // OPEN: Require ALL main fingers to be open to drop
            if (isIndexOpen && isMiddleOpen && isRingOpen && isPinkyOpen) {
                gestureState = 'OPEN';
            }
            // FIST: Index, Middle, Ring, Pinky are CLOSED
            else if (!isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) {
                gestureState = 'FIST';
            }
            // POINTING: Index Open, Middle/Ring/Pinky Closed.
            // Relaxed check: We don't care about the thumb for pointing to make it easier
            else if (isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) {
                gestureState = 'POINTING';
            }
            else {
                gestureState = 'UNKNOWN';
            }
        }

        function handleInteraction(landmarks) {
            // Draw loading circle helper
            const centerX = (1 - landmarks[9].x) * canvasElement.width;
            const centerY = landmarks[9].y * canvasElement.height;

            // FIX: IMMEDIATE RESET ON OPEN HAND
            if (gestureState === 'OPEN') {
                if (interactionState !== 'IDLE') {
                    resetInteraction();
                }
                return; // Exit early
            }

            if (gestureState === 'FIST') {
                if (interactionState === 'IDLE' || interactionState === 'CHARGING') {
                    if (interactionState === 'IDLE') {
                        interactionState = 'CHARGING';
                        grabStartTime = Date.now();
                        updateStatus('INITIATING LINK...');
                    }

                    const elapsed = Date.now() - grabStartTime;
                    
                    // Draw Loading Circle on Preview
                    canvasCtx.beginPath();
                    canvasCtx.arc(centerX, centerY, 20, 0, (elapsed / GRAB_DELAY) * 2 * Math.PI);
                    canvasCtx.strokeStyle = '#00ff00';
                    canvasCtx.lineWidth = 4;
                    canvasCtx.stroke();

                    if (elapsed >= GRAB_DELAY) {
                        interactionState = 'GRABBED';
                        updateStatus('OBJECT LINKED');
                        wireframe.material.color.setHex(0x00ff00);
                    }
                }
            } else if (gestureState === 'POINTING') {
                 if (interactionState === 'GRABBED' || interactionState === 'ROTATING') {
                    interactionState = 'ROTATING';
                    updateStatus('ROTATING');
                    wireframe.material.color.setHex(0xffff00);

                    // Calculate Angle based on Index Finger (Wrist -> Tip)
                    const visualWristX = 1 - landmarks[0].x; // Mirror X
                    const visualWristY = landmarks[0].y;
                    const visualTipX = 1 - landmarks[8].x; // Mirror X
                    const visualTipY = landmarks[8].y;

                    // Math.atan2(dy, dx) gives angle in radians
                    const angle = Math.atan2(visualTipY - visualWristY, visualTipX - visualWristX);
                    
                    // Set target rotation
                    // -angle reverses the direction to match mirror logic
                    // -PI/2 aligns "Up" (screen -Y) to 0 rotation
                    targetRotationZ = -angle - (Math.PI / 2); 
                    targetRotationX = angle * 0.2; // Slight tilt
                 }
            } else {
                // If unknown gesture during charge, cancel charge
                if (interactionState === 'CHARGING') {
                    interactionState = 'IDLE';
                    updateStatus('ABORTED');
                }
                // If UNKNOWN while GRABBED or ROTATING, we KEEP the state (don't drop)
                // but we stop updating the rotation target (so it freezes in place)
            }

            // Move Cube if Grabbed or Rotating
            if (interactionState === 'GRABBED' || interactionState === 'ROTATING') {
                const { width: visibleWidth, height: visibleHeight } = getVisibleDimensions(cube.position.z, camera);
                const targetX = (handX - 0.5) * visibleWidth;
                const targetY = -(handY - 0.5) * visibleHeight;
                
                cube.position.x += (targetX - cube.position.x) * 0.2;
                cube.position.y += (targetY - cube.position.y) * 0.2;
                
                if (interactionState === 'ROTATING') {
                     // FIX: SHORTEST ANGLE INTERPOLATION
                     // This prevents spinning when crossing the 180/-180 degree boundary
                     let diffZ = targetRotationZ - cube.rotation.z;
                     // Normalize diffZ to -PI to PI
                     while (diffZ > Math.PI) diffZ -= 2 * Math.PI;
                     while (diffZ < -Math.PI) diffZ += 2 * Math.PI;

                     cube.rotation.z += diffZ * 0.15; // Slightly faster reaction
                     cube.rotation.x += (targetRotationX - cube.rotation.x) * 0.1;
                }
            } else {
                // Idle Animation
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
            }
        }

        function updateStatus(text) {
            statusElement.innerText = text;
            if(text === 'OBJECT LINKED') statusElement.style.color = '#0f0';
            else if (text === 'ROTATING') statusElement.style.color = '#ff0';
            else statusElement.style.color = '#f0f';
        }

        // --- 5. MAIN ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>