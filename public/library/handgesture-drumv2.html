<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Drum Kit V2 (Pinch Mode)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Kanit:wght@300;400&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { background-color: #050505; color: white; font-family: 'Kanit', sans-serif; overflow: hidden; }
        .brand-font { font-family: 'Orbitron', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* Video Mirror */
        #webcam { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        /* Canvas Normal */
        #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        
        .ui-overlay { position: absolute; z-index: 20; pointer-events: none; }
        .pointer-auto { pointer-events: auto; }

        /* HUD Styles */
        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .drum-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            opacity: 0.5;
            transition: all 0.1s;
        }
        .drum-indicator.active {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
            font-weight: bold;
            transform: scale(1.05);
        }
        .key-badge {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: #aaa;
        }
        
        /* Zone Divider (Optional Visual Guide) */
        .zone-divider {
            position: absolute;
            left: 50%;
            top: 20%;
            bottom: 20%;
            width: 1px;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
        <div class="zone-divider"></div>

        <!-- Header -->
        <div class="ui-overlay top-4 left-4 bg-black/60 p-4 rounded-xl border border-cyan-500/30 backdrop-blur-md">
            <h1 class="text-2xl font-bold text-cyan-400 flex items-center gap-2 brand-font">
                <i data-lucide="zap"></i> PINCH DRUMS V2
            </h1>
            <p class="text-xs text-gray-300 mt-1">‡∏à‡∏µ‡∏ö‡∏ô‡∏¥‡πâ‡∏ß‡πÇ‡∏õ‡πâ‡∏á‡∏Å‡∏±‡∏ö‡∏ô‡∏¥‡πâ‡∏ß‡∏≠‡∏∑‡πà‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏µ‡∏Å‡∏•‡∏≠‡∏á (1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á/‡∏à‡∏µ‡∏ö)</p>
            <div id="status" class="mt-2 text-xs flex items-center gap-2 text-yellow-400">
                <div class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                Waiting...
            </div>
        </div>

        <!-- HUD: Left Hand Mapping -->
        <div class="ui-overlay left-4 top-1/2 -translate-y-1/2 hud-panel border-pink-500/30">
            <div class="text-pink-400 font-bold text-xs mb-1 text-center">LEFT HAND (Left Zone)</div>
            <div id="ind-snare" class="drum-indicator"><span class="key-badge">‚òùÔ∏è</span> Snare</div>
            <div id="ind-kick" class="drum-indicator"><span class="key-badge">üñï</span> Kick</div>
            <div id="ind-ride" class="drum-indicator"><span class="key-badge">üññ</span> Ride</div>
            <div id="ind-clap" class="drum-indicator"><span class="key-badge">ü§ô</span> Clap</div>
        </div>

        <!-- HUD: Right Hand Mapping -->
        <div class="ui-overlay right-4 top-1/2 -translate-y-1/2 hud-panel border-cyan-500/30">
            <div class="text-cyan-400 font-bold text-xs mb-1 text-center">RIGHT HAND (Right Zone)</div>
            <div id="ind-hihat" class="drum-indicator"><span class="key-badge">‚òùÔ∏è</span> Hi-Hat</div>
            <div id="ind-crash" class="drum-indicator"><span class="key-badge">üñï</span> Crash</div>
            <div id="ind-tom1" class="drum-indicator"><span class="key-badge">üññ</span> Tom 1</div>
            <div id="ind-tom2" class="drum-indicator"><span class="key-badge">ü§ô</span> Tom 2</div>
        </div>
        
        <!-- Start Screen -->
        <div id="startScreen" class="ui-overlay inset-0 flex items-center justify-center bg-black/90 z-50 pointer-auto">
            <div class="text-center p-8 border border-cyan-500 rounded-2xl bg-gray-900/90 shadow-[0_0_30px_rgba(6,182,212,0.3)]">
                <i data-lucide="hand" class="w-16 h-16 text-cyan-500 mx-auto mb-4"></i>
                <h2 class="text-3xl font-bold brand-font mb-2">PINCH MODE</h2>
                <p class="text-gray-400 mb-6">‡∏à‡∏µ‡∏ö‡∏ô‡∏¥‡πâ‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞<br>‡∏ã‡πâ‡∏≤‡∏¢‡∏Ñ‡∏∏‡∏°‡∏ã‡πâ‡∏≤‡∏¢ ‡∏Ç‡∏ß‡∏≤‡∏Ñ‡∏∏‡∏°‡∏Ç‡∏ß‡∏≤</p>
                <button id="startBtn" class="px-8 py-3 bg-gradient-to-r from-cyan-600 to-blue-600 hover:scale-105 transition rounded-full font-bold text-lg shadow-lg">
                    START
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        lucide.createIcons();

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');

        let handLandmarker;
        let webcamRunning = false;
        let audioContext;

        // --- 1. Audio System (Synthesizer) ---
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Noise Buffer for Snare/Cymbals
        let noiseBuffer = null;
        function getNoiseBuffer() {
            if (!noiseBuffer) {
                const bufferSize = audioContext.sampleRate * 2; 
                noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
            }
            return noiseBuffer;
        }

        function playSynth(type) {
            if (!audioContext || audioContext.state === 'suspended') audioContext?.resume();
            const t = audioContext.currentTime;

            if (type === 'kick') {
                const osc = audioContext.createOscillator();
                const g = audioContext.createGain();
                osc.connect(g);
                g.connect(audioContext.destination);
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                g.gain.setValueAtTime(1, t);
                g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.start(t); osc.stop(t + 0.5);
            } 
            else if (type === 'snare') {
                const noise = audioContext.createBufferSource();
                noise.buffer = getNoiseBuffer();
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 1000;
                const g = audioContext.createGain();
                noise.connect(filter); filter.connect(g); g.connect(audioContext.destination);
                g.gain.setValueAtTime(1, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                noise.start(t); noise.stop(t + 0.2);
                
                const osc = audioContext.createOscillator();
                osc.type = 'triangle';
                const og = audioContext.createGain();
                osc.connect(og); og.connect(audioContext.destination);
                osc.frequency.setValueAtTime(250, t);
                og.gain.setValueAtTime(0.5, t); og.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t); osc.stop(t + 0.1);
            }
            else if (type === 'hihat') {
                const noise = audioContext.createBufferSource();
                noise.buffer = getNoiseBuffer();
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 5000;
                const g = audioContext.createGain();
                noise.connect(filter); filter.connect(g); g.connect(audioContext.destination);
                g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                noise.start(t); noise.stop(t + 0.05);
            }
            else if (type === 'crash') {
                const noise = audioContext.createBufferSource();
                noise.buffer = getNoiseBuffer();
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 3000;
                const g = audioContext.createGain();
                noise.connect(filter); filter.connect(g); g.connect(audioContext.destination);
                g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.01, t + 1.2);
                noise.start(t); noise.stop(t + 1.2);
            }
            else if (type === 'tom1') { // High Tom
                const osc = audioContext.createOscillator();
                const g = audioContext.createGain();
                osc.connect(g); g.connect(audioContext.destination);
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.3);
                g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc.start(t); osc.stop(t + 0.3);
            }
            else if (type === 'tom2') { // Low Tom
                const osc = audioContext.createOscillator();
                const g = audioContext.createGain();
                osc.connect(g); g.connect(audioContext.destination);
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(30, t + 0.4);
                g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.start(t); osc.stop(t + 0.4);
            }
            else if (type === 'ride') { // Metallic
                const osc = audioContext.createOscillator();
                osc.type = 'square'; // Metal-ish
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass'; filter.frequency.value = 8000;
                const g = audioContext.createGain();
                osc.connect(filter); filter.connect(g); g.connect(audioContext.destination);
                g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
                osc.start(t); osc.stop(t + 0.8);
            }
            else if (type === 'clap') {
                const noise = audioContext.createBufferSource();
                noise.buffer = getNoiseBuffer();
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass'; filter.frequency.value = 1500; filter.Q.value = 1;
                const g = audioContext.createGain();
                noise.connect(filter); filter.connect(g); g.connect(audioContext.destination);
                // Fake Clap Envelope
                g.gain.setValueAtTime(0.8, t);
                g.gain.exponentialRampToValueAtTime(0.1, t + 0.01);
                g.gain.setValueAtTime(0.8, t + 0.015);
                g.gain.exponentialRampToValueAtTime(0.1, t + 0.025);
                g.gain.setValueAtTime(0.8, t + 0.030);
                g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                noise.start(t); noise.stop(t + 0.2);
            }
        }

        // --- 2. Logic & Config ---
        // Finger Indices: 4=Thumb, 8=Index, 12=Middle, 16=Ring, 20=Pinky
        
        const DRUM_MAP = {
            "Right": {
                8: { id: "hihat", type: "hihat", color: "#22d3ee" },
                12: { id: "crash", type: "crash", color: "#eab308" },
                16: { id: "tom1", type: "tom1", color: "#a855f7" },
                20: { id: "tom2", type: "tom2", color: "#6366f1" }
            },
            "Left": {
                8: { id: "snare", type: "snare", color: "#ec4899" },
                12: { id: "kick", type: "kick", color: "#f43f5e" },
                16: { id: "ride", type: "ride", color: "#14b8a6" },
                20: { id: "clap", type: "clap", color: "#f97316" }
            }
        };

        // State to track if a finger pair is currently pinched
        // Key: "Handedness-FingerIndex" e.g., "Left-8"
        const pinchState = {}; 

        // HUD Elements
        const hudElements = {};
        ["snare", "kick", "ride", "clap", "hihat", "crash", "tom1", "tom2"].forEach(id => {
            hudElements[id] = document.getElementById(`ind-${id}`);
        });

        function triggerVisual(id) {
            const el = hudElements[id];
            if(el) {
                el.classList.add('active');
                setTimeout(() => el.classList.remove('active'), 150);
            }
        }

        // --- 3. Start System ---
        startBtn.addEventListener('click', async () => {
            initAudio();
            if (audioContext.state === 'suspended') await audioContext.resume();
            startScreen.style.opacity = '0';
            setTimeout(() => startScreen.style.display = 'none', 500);
            if (!handLandmarker) setupAI();
        });

        // --- 4. Vision Setup ---
        async function setupAI() {
            try {
                statusEl.innerHTML = "Loading AI...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 2
                });
                statusEl.innerHTML = `<span class="text-green-400">‚óè System Ready</span>`;
                startCam();
            } catch (err) {
                console.error(err);
                statusEl.textContent = "Error: " + err.message;
            }
        }

        function startCam() {
            if (navigator.mediaDevices?.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                    video.srcObject = stream;
                    webcamRunning = true;
                    video.addEventListener("loadeddata", predictLoop);
                });
            }
        }

        // --- 5. Main Loop ---
        let lastVideoTime = -1;
        
        // Settings for Hysteresis to prevent looping
        const PINCH_START = 0.04; // ‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏µ‡∏ö‡πÉ‡∏´‡πâ‡∏ä‡∏¥‡∏î‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡∏µ‡πâ‡∏ñ‡∏∂‡∏á‡∏à‡∏∞‡∏ï‡∏¥‡∏î (Trigger)
        const PINCH_RELEASE = 0.05; // ‡∏ï‡πâ‡∏≠‡∏á‡∏ñ‡πà‡∏≤‡∏á‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡∏µ‡πâ‡∏ñ‡∏∂‡∏á‡∏à‡∏∞ Reset (Release)

        async function predictLoop() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const startTimeMs = performance.now();
                const results = handLandmarker.detectForVideo(video, startTimeMs);

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (results.landmarks) {
                    for (let i = 0; i < results.landmarks.length; i++) {
                        const landmarks = results.landmarks[i];
                        
                        // --- ROBUST HANDEDNESS LOGIC ---
                        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠ label ‡∏à‡∏≤‡∏Å AI 100% ‡∏ã‡∏∂‡πà‡∏á‡∏°‡∏±‡∏Å‡∏™‡∏±‡∏ö‡∏™‡∏ô‡πÉ‡∏ô‡∏Å‡∏£‡∏∞‡∏à‡∏Å
                        // ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ "‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠" ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡∏´‡∏•‡∏±‡∏Å
                        // ‡∏°‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏ù‡∏±‡πà‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏à‡∏≠ = ‡∏°‡∏∑‡∏≠‡∏ã‡πâ‡∏≤‡∏¢ (Left Map)
                        // ‡∏°‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏ù‡∏±‡πà‡∏á‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á‡∏à‡∏≠ = ‡∏°‡∏∑‡∏≠‡∏Ç‡∏ß‡∏≤ (Right Map)
                        
                        // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏°‡∏∑‡∏≠ (Wrist landmark 0)
                        const wrist = landmarks[0];
                        // ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å Video Mirror (scaleX -1) -> ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á x ‡∏ó‡∏µ‡πà MediaPipe ‡πÉ‡∏´‡πâ‡∏°‡∏≤:
                        // x=0 ‡∏Ñ‡∏∑‡∏≠‡∏ã‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö (‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏∑‡∏≠‡∏Ç‡∏ß‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏à‡∏≠‡∏Å‡∏£‡∏∞‡∏à‡∏Å)
                        // x=1 ‡∏Ñ‡∏∑‡∏≠‡∏Ç‡∏ß‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö (‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏∑‡∏≠‡∏ã‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏à‡∏≠‡∏Å‡∏£‡∏∞‡∏à‡∏Å)
                        // Visual X (‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏î‡∏ö‡∏ô Canvas) = (1 - x)
                        
                        // ‡∏ñ‡πâ‡∏≤ Visual X < 0.5 (‡∏ù‡∏±‡πà‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏à‡∏≠) -> Left Hand
                        // ‡∏ñ‡πâ‡∏≤ Visual X > 0.5 (‡∏ù‡∏±‡πà‡∏á‡∏Ç‡∏ß‡∏≤‡∏à‡∏≠) -> Right Hand
                        
                        const isVisualLeft = (1 - wrist.x) < 0.5;
                        const handedness = isVisualLeft ? "Left" : "Right";

                        // Draw Hand
                        drawHand(landmarks, handedness === "Left" ? "#ec4899" : "#22d3ee");

                        // Check Pinches
                        const thumbTip = landmarks[4];
                        const fingers = [8, 12, 16, 20];

                        fingers.forEach(fingerIdx => {
                            const fingerTip = landmarks[fingerIdx];
                            const dist = Math.hypot(thumbTip.x - fingerTip.x, thumbTip.y - fingerTip.y);
                            
                            const key = `${handedness}-${fingerIdx}`;
                            
                            // --- HYSTERESIS LOGIC (Single Trigger) ---
                            // 1. ‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏Å‡πà‡∏≤‡∏°‡∏≤
                            const wasPinched = pinchState[key] || false;
                            
                            // 2. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏´‡∏°‡πà
                            let isPinched = wasPinched; // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
                            
                            if (dist < PINCH_START) {
                                isPinched = true; // ‡∏ä‡∏¥‡∏î‡∏û‡∏≠‡∏ó‡∏µ‡πà‡∏à‡∏∞ Trigger
                            } else if (dist > PINCH_RELEASE) {
                                isPinched = false; // ‡∏´‡πà‡∏≤‡∏á‡∏û‡∏≠‡∏ó‡∏µ‡πà‡∏à‡∏∞ Reset
                            }
                            
                            // 3. Trigger only on Rising Edge (False -> True)
                            if (isPinched && !wasPinched) {
                                const map = DRUM_MAP[handedness];
                                if (map && map[fingerIdx]) {
                                    const drum = map[fingerIdx];
                                    playSynth(drum.type);
                                    triggerVisual(drum.id);
                                    
                                    const x = (1 - thumbTip.x) * canvas.width;
                                    const y = thumbTip.y * canvas.height;
                                    drawExplosion(x, y, drum.color);
                                }
                            }

                            // 4. ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
                            pinchState[key] = isPinched;
                        });
                    }
                }
            }

            if (webcamRunning) window.requestAnimationFrame(predictLoop);
        }

        // --- Visual Helpers ---
        function drawHand(landmarks, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.6;
            
            const connections = HandLandmarker.HAND_CONNECTIONS;
            ctx.beginPath();
            for (const c of connections) {
                const p1 = landmarks[c.start];
                const p2 = landmarks[c.end];
                ctx.moveTo((1-p1.x)*canvas.width, p1.y*canvas.height);
                ctx.lineTo((1-p2.x)*canvas.width, p2.y*canvas.height);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        function drawExplosion(x, y, color) {
            ctx.beginPath();
            ctx.arc(x, y, 30, 0, 2*Math.PI);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, 2*Math.PI);
            ctx.fillStyle = "white";
            ctx.fill();
        }

    </script>
</body>
</html>