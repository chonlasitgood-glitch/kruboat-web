<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Atomic Builder: Chemistry Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f4f8;
            font-family: 'Kanit', sans-serif;
            touch-action: none;
            user-select: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            color: #2d3748;
        }

        #game-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #ffffff 0%, #e2e8f0 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI */
        .header {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        .target-card {
            background: white;
            padding: 10px 25px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: inline-block;
        }

        .formula {
            font-size: 2.5rem;
            font-weight: bold;
            color: #4a5568;
            line-height: 1;
        }

        .sub {
            font-size: 0.6em;
            vertical-align: sub;
        }

        .chem-name {
            display: block;
            color: #718096;
            font-size: 1rem;
            margin-top: 5px;
        }

        .instruction {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #718096;
            font-size: 0.9rem;
            pointer-events: none;
            animation: bounce 2s infinite;
        }

        .btn-reset {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            border: 1px solid #cbd5e0;
            color: #718096;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            z-index: 20;
            pointer-events: auto;
        }

        /* Modal */
        .modal {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal.active { opacity: 1; pointer-events: auto; }

        .modal h1 {
            font-size: 3rem;
            color: #48bb78;
            margin-bottom: 10px;
        }

        .btn-next {
            background: #48bb78;
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 1.5rem;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.4);
            font-family: 'Kanit', sans-serif;
            transition: transform 0.1s;
        }
        .btn-next:active { transform: scale(0.95); }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div class="header">
            <div class="target-card">
                <div class="formula" id="formula-display">H<span class="sub">2</span>O</div>
                <span class="chem-name" id="name-display">Water (น้ำ)</span>
            </div>
        </div>

        <button class="btn-reset" onclick="resetLevel()">↺</button>
        <div class="instruction">ลากเส้นเชื่อมจุดเพื่อสร้างพันธะ</div>

        <!-- Win Modal -->
        <div id="winModal" class="modal">
            <h1>ถูกต้อง!</h1>
            <p style="color: #718096; font-size: 1.2rem; margin-bottom: 30px;">โครงสร้างโมเลกุลเสถียรแล้ว</p>
            <button class="btn-next" onclick="nextLevel()">ด่านถัดไป</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        let width, height;
        let atoms = [];
        let bonds = [];
        let currentLevel = 0;
        let isDragging = false;
        let dragStartAtom = null;
        let dragCurrentPos = { x: 0, y: 0 };
        let win = false;

        // Configuration
        const ELEMENTS = {
            H: { color: '#ffffff', stroke: '#cbd5e0', radius: 25, valence: 1, label: 'H' },
            O: { color: '#fc8181', stroke: '#c53030', radius: 35, valence: 2, label: 'O' },
            C: { color: '#4a5568', stroke: '#1a202c', radius: 35, valence: 4, label: 'C' },
            N: { color: '#63b3ed', stroke: '#2b6cb0', radius: 35, valence: 3, label: 'N' }
        };

        const LEVELS = [
            { 
                formula: 'H₂', name: 'Hydrogen Gas (ก๊าซไฮโดรเจน)', 
                atoms: ['H', 'H'] 
            },
            { 
                formula: 'O₂', name: 'Oxygen Gas (ก๊าซออกซิเจน)', 
                atoms: ['O', 'O'] 
            },
            { 
                formula: 'H₂O', name: 'Water (น้ำ)', 
                atoms: ['H', 'H', 'O'] 
            },
            { 
                formula: 'CO₂', name: 'Carbon Dioxide (คาร์บอนไดออกไซด์)', 
                atoms: ['O', 'C', 'O'] 
            },
            { 
                formula: 'CH₄', name: 'Methane (มีเทน)', 
                atoms: ['C', 'H', 'H', 'H', 'H'] 
            }
        ];

        class Atom {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.props = ELEMENTS[type];
                this.bonds = 0; // Current bonds count
                this.id = Math.random().toString(36).substr(2, 9);
            }

            draw(ctx) {
                // Shadow
                ctx.beginPath();
                ctx.arc(this.x, this.y + 3, this.props.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.props.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.props.color;
                ctx.fill();
                ctx.lineWidth = 3;
                ctx.strokeStyle = this.props.stroke;
                ctx.stroke();

                // Label
                ctx.fillStyle = this.props.stroke;
                ctx.font = `bold ${this.props.radius}px Kanit`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.props.label, this.x, this.y);

                // Slots indicator (Dots around)
                const total = this.props.valence;
                const current = this.bonds;
                const r = this.props.radius + 8;
                
                for(let i=0; i<total; i++) {
                    const angle = (i / total) * Math.PI * 2 - Math.PI/2;
                    const bx = this.x + Math.cos(angle) * r;
                    const by = this.y + Math.sin(angle) * r;
                    
                    ctx.beginPath();
                    ctx.arc(bx, by, 4, 0, Math.PI*2);
                    if (i < current) {
                        ctx.fillStyle = '#48bb78'; // Filled
                    } else {
                        ctx.fillStyle = '#cbd5e0'; // Empty
                    }
                    ctx.fill();
                }
            }

            update() {
                // Simple physics to keep them floating but separate
                this.x += this.vx;
                this.y += this.vy;
                
                // Friction
                this.vx *= 0.9;
                this.vy *= 0.9;

                // Wall bounce
                if(this.x < this.props.radius) this.vx += 1;
                if(this.x > width/dpr - this.props.radius) this.vx -= 1;
                if(this.y < this.props.radius + 100) this.vy += 1;
                if(this.y > height/dpr - this.props.radius) this.vy -= 1;

                // Repel others
                atoms.forEach(other => {
                    if(other === this) return;
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const dist = Math.hypot(dx, dy);
                    const minDist = this.props.radius + other.props.radius + 20;

                    if(dist < minDist) {
                        const force = (minDist - dist) * 0.05;
                        const angle = Math.atan2(dy, dx);
                        this.vx += Math.cos(angle) * force;
                        this.vy += Math.sin(angle) * force;
                    }
                });
            }
        }

        class Bond {
            constructor(a1, a2) {
                this.a1 = a1;
                this.a2 = a2;
                this.strength = 1; // 1 = Single, 2 = Double, 3 = Triple
            }

            draw(ctx) {
                const dx = this.a2.x - this.a1.x;
                const dy = this.a2.y - this.a1.y;
                const dist = Math.hypot(dx, dy);
                const angle = Math.atan2(dy, dx);

                ctx.save();
                ctx.translate((this.a1.x + this.a2.x)/2, (this.a1.y + this.a2.y)/2);
                ctx.rotate(angle);

                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.strokeStyle = '#718096';

                if(this.strength === 1) {
                    ctx.beginPath();
                    ctx.moveTo(-dist/2, 0);
                    ctx.lineTo(dist/2, 0);
                    ctx.stroke();
                } else if (this.strength === 2) {
                    ctx.beginPath();
                    ctx.moveTo(-dist/2, -5);
                    ctx.lineTo(dist/2, -5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-dist/2, 5);
                    ctx.lineTo(dist/2, 5);
                    ctx.stroke();
                }

                ctx.restore();
            }

            update() {
                // Spring physics to pull atoms together
                const dx = this.a2.x - this.a1.x;
                const dy = this.a2.y - this.a1.y;
                const dist = Math.hypot(dx, dy);
                const targetDist = this.a1.props.radius + this.a2.props.radius + 40;

                const force = (dist - targetDist) * 0.05;
                const angle = Math.atan2(dy, dx);
                
                const fx = Math.cos(angle) * force;
                const fy = Math.sin(angle) * force;

                this.a1.vx += fx;
                this.a1.vy += fy;
                this.a2.vx -= fx;
                this.a2.vy -= fy;
            }
        }

        // --- Core ---

        function init() {
            window.addEventListener('resize', resize);
            resize();
            
            canvas.addEventListener('pointerdown', handleStart);
            window.addEventListener('pointermove', handleMove);
            window.addEventListener('pointerup', handleEnd);

            loadLevel(0);
            loop();
        }

        function resize() {
            const container = document.getElementById('game-container');
            width = container.clientWidth * dpr;
            height = container.clientHeight * dpr;
            canvas.width = width;
            canvas.height = height;
            ctx.scale(dpr, dpr);
        }

        function loadLevel(idx) {
            win = false;
            document.getElementById('winModal').classList.remove('active');
            
            const lvl = LEVELS[idx];
            document.getElementById('formula-display').innerHTML = formatFormula(lvl.formula);
            document.getElementById('name-display').innerText = lvl.name;

            // Spawn Atoms randomly
            atoms = [];
            bonds = [];
            
            const w = width/dpr;
            const h = height/dpr;
            
            lvl.atoms.forEach(type => {
                const x = w/2 + (Math.random()-0.5) * 200;
                const y = h/2 + (Math.random()-0.5) * 200;
                atoms.push(new Atom(type, x, y));
            });
        }

        function formatFormula(f) {
            return f.replace(/(\d+)/g, '<span class="sub">$1</span>');
        }

        function checkWin() {
            // Check if every atom has filled bonds exactly
            const allHappy = atoms.every(a => a.bonds === a.props.valence);
            
            // Basic check: is everyone connected in one group? (DFS/BFS) 
            // For now, simpler check: Are all required valencies filled?
            // Since we limit bonds to valence, if everyone is full, it's likely correct for these simple levels.
            
            if (allHappy && !win) {
                win = true;
                setTimeout(() => {
                    document.getElementById('winModal').classList.add('active');
                }, 500);
            }
        }

        // --- Input ---

        function handleStart(e) {
            if(win) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find clicked atom
            const atom = atoms.find(a => Math.hypot(a.x - x, a.y - y) < a.props.radius + 10);
            
            if (atom) {
                isDragging = true;
                dragStartAtom = atom;
                dragCurrentPos = {x, y};
            }
        }

        function handleMove(e) {
            if(isDragging) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                dragCurrentPos.x = e.clientX - rect.left;
                dragCurrentPos.y = e.clientY - rect.top;
            }
        }

        function handleEnd(e) {
            if(!isDragging) return;
            isDragging = false;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find target atom
            const targetAtom = atoms.find(a => Math.hypot(a.x - x, a.y - y) < a.props.radius + 10);

            if (targetAtom && targetAtom !== dragStartAtom) {
                tryBond(dragStartAtom, targetAtom);
            }

            dragStartAtom = null;
        }

        function tryBond(a1, a2) {
            // Check if slots available
            if (a1.bonds >= a1.props.valence || a2.bonds >= a2.props.valence) {
                // Wiggle effect for error?
                return;
            }

            // Check if bond already exists
            const existingBond = bonds.find(b => (b.a1 === a1 && b.a2 === a2) || (b.a1 === a2 && b.a2 === a1));

            if (existingBond) {
                // Upgrade to Double/Triple bond if possible
                if (a1.bonds + 1 <= a1.props.valence && a2.bonds + 1 <= a2.props.valence) {
                    existingBond.strength++;
                    a1.bonds++;
                    a2.bonds++;
                    checkWin();
                }
            } else {
                // Create new bond
                bonds.push(new Bond(a1, a2));
                a1.bonds++;
                a2.bonds++;
                checkWin();
            }
        }

        // --- Loop ---

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            atoms.forEach(a => a.update());
            bonds.forEach(b => b.update());
        }

        function draw() {
            ctx.clearRect(0, 0, width/dpr, height/dpr);

            // Draw Bonds first (behind atoms)
            bonds.forEach(b => b.draw(ctx));

            // Draw Drag Line
            if (isDragging && dragStartAtom) {
                ctx.beginPath();
                ctx.moveTo(dragStartAtom.x, dragStartAtom.y);
                ctx.lineTo(dragCurrentPos.x, dragCurrentPos.y);
                ctx.strokeStyle = '#a0aec0';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw Atoms
            atoms.forEach(a => a.draw(ctx));
        }

        // --- Utils ---

        function resetLevel() {
            loadLevel(currentLevel);
        }

        function nextLevel() {
            currentLevel++;
            if(currentLevel >= LEVELS.length) {
                currentLevel = 0;
                alert("ยินดีด้วย! คุณเป็นสุดยอดนักเคมีแล้ว");
            }
            loadLevel(currentLevel);
        }

        window.onload = init;

    </script>
</body>
</html>