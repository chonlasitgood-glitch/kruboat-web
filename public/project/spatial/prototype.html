<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Spatial Math + Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Sarabun:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Three.js & OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body {
            background-color: #000;
            color: white;
            font-family: 'Sarabun', sans-serif;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #webcam, #output_canvas, #three_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .mirror-mode {
            transform: scaleX(-1);
        }
        #three_canvas {
            pointer-events: auto;
            cursor: default;
        }
        .ui-overlay {
            position: absolute;
            z-index: 20;
        }
        .tech-font {
            font-family: 'Orbitron', sans-serif;
        }
        
        /* Sidebar Styling */
        #level-menu {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 300px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(0, 255, 255, 0.2);
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 30;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        }
        #level-menu.open {
            transform: translateX(0);
        }
        
        .level-card {
            transition: all 0.2s;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .level-card:hover {
            background: rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.5);
        }
        .level-card.active {
            background: rgba(6, 182, 212, 0.3);
            border-color: #06b6d4;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
        }

        /* Builder UI */
        #builder-ui {
            display: none;
        }
        #builder-ui.active {
            display: flex;
        }

        .tool-btn.active {
            background-color: #2563eb;
            border-color: #60a5fa;
            color: white;
            box-shadow: 0 0 10px rgba(37, 99, 235, 0.5);
        }

        /* Range Slider */
        input[type=range] {
            -webkit-appearance: none; 
            appearance: none;
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #06b6d4;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(6, 182, 212, 0.8);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <div id="container">
        <!-- 1. Media Layers -->
        <video id="webcam" class="mirror-mode" autoplay playsinline></video>
        <canvas id="output_canvas" class="mirror-mode"></canvas>
        <canvas id="three_canvas"></canvas>

        <!-- 2. Play Mode UI -->
        <div id="play-ui" class="ui-overlay top-4 left-4 right-16 md:right-auto bg-black/60 p-3 md:p-5 rounded-xl border border-cyan-500/50 backdrop-blur-md shadow-lg shadow-cyan-500/20 pointer-events-none transition-opacity duration-300 md:min-w-[280px]">
            <h1 class="text-lg md:text-2xl font-bold text-cyan-300 flex items-center gap-2 tech-font">
                <i data-lucide="cuboid" class="w-5 h-5 md:w-6 md:h-6"></i> SPATIAL MATH
            </h1>
            <p class="text-sm md:text-base text-white mt-1 font-bold" id="question-text">Level: ...</p>
            <p class="text-xs md:text-sm text-gray-300 mt-1 mb-2">üí° Raise index finger to control</p>
            
            <!-- Controls: Count Buttons -->
            <div class="space-y-2 pointer-events-auto">
                <div class="flex items-center justify-between gap-2 bg-gray-800/80 p-2 rounded-lg border border-gray-600">
                    <button id="countPrevBtn" class="p-2 bg-gray-700 hover:bg-gray-600 rounded-full text-white disabled:opacity-50 transition shadow-md">
                        <i data-lucide="chevron-left" class="w-4 h-4 md:w-5 md:h-5"></i>
                    </button>
                    
                    <span class="text-gray-400 text-xs md:text-sm font-bold uppercase tracking-wider">Count</span>

                    <button id="countNextBtn" class="p-2 bg-green-600 hover:bg-green-500 rounded-full text-white disabled:opacity-50 transition shadow-md shadow-green-900/50">
                        <i data-lucide="chevron-right" class="w-4 h-4 md:w-5 md:h-5"></i>
                    </button>
                    
                    <div class="w-px h-6 bg-gray-600 mx-1"></div>
                    
                    <button id="resetStateBtn" class="p-2 bg-red-900/80 hover:bg-red-700 rounded-full text-red-200 transition shadow-md" title="Reset">
                        <i data-lucide="rotate-ccw" class="w-4 h-4 md:w-5 md:h-5"></i>
                    </button>
                </div>
            </div>

            <div id="status" class="mt-2 text-[10px] md:text-xs flex items-center gap-2 text-yellow-400">
                <div class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                <span id="status-text">Initializing...</span>
            </div>
        </div>
        
        <!-- Sidebar Toggle -->
        <div class="ui-overlay top-4 right-4 pointer-events-auto z-40">
            <button id="toggleMenu" class="p-2 md:p-3 bg-cyan-900/80 hover:bg-cyan-700 text-white rounded-lg border border-cyan-500/50 transition shadow-[0_0_15px_rgba(6,182,212,0.3)]">
                <i data-lucide="menu"></i>
            </button>
        </div>

        <!-- Level Menu -->
        <div id="level-menu" class="open">
            <div class="p-4 sticky top-0 bg-black/95 backdrop-blur-md border-b border-gray-800 z-10 flex justify-between items-center h-[60px] md:h-[74px] shrink-0">
                <h2 class="text-lg font-bold text-cyan-400 tech-font">LEVELS</h2>
            </div>
            
            <div class="p-3 border-b border-gray-800 shrink-0">
                <button onclick="startBuilderMode()" class="w-full py-3 bg-green-600 hover:bg-green-500 text-white rounded-lg font-bold flex justify-center items-center gap-2 transition text-sm md:text-base">
                    <i data-lucide="plus-square" class="w-4 h-4"></i> Create New Level
                </button>
            </div>

            <div class="p-3 flex-grow overflow-y-auto">
                <h3 class="text-xs text-gray-500 font-bold mb-2 uppercase">Standard Levels</h3>
                <div id="level-list" class="space-y-2"></div>
                
                <h3 class="text-xs text-gray-500 font-bold mt-4 mb-2 uppercase">My Custom Levels</h3>
                <div id="custom-level-list" class="space-y-2">
                    <p class="text-xs text-gray-600 italic text-center py-2">No custom levels yet</p>
                </div>
            </div>

            <!-- Developer Credit Footer -->
            <div class="p-4 border-t border-gray-800 bg-black/50 text-center shrink-0">
                <p class="text-[10px] text-gray-500 uppercase tracking-widest font-bold">Developed By</p>
                <p class="text-xs text-cyan-400 mt-1 font-medium">Your Name / Research Team</p>
            </div>
        </div>

        <!-- Start Camera Button -->
        <div id="play-controls" class="ui-overlay bottom-6 left-1/2 transform -translate-x-1/2 pointer-events-auto transition-opacity duration-300 w-full flex justify-center px-4">
            <button id="toggleCam" disabled class="w-full max-w-xs px-6 py-3 bg-gray-600 cursor-not-allowed opacity-50 rounded-full hover:scale-105 transition shadow-[0_0_20px_rgba(79,70,229,0.5)] flex items-center justify-center gap-2 text-base md:text-lg font-bold text-white">
                <div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div> 
                <span id="btn-text">Loading AI...</span>
            </button>
        </div>

        <!-- Rotation Controls -->
        <div id="rotation-controls" class="ui-overlay bottom-24 left-1/2 transform -translate-x-1/2 md:translate-x-0 md:left-4 md:bottom-8 pointer-events-auto transition-opacity duration-300 flex flex-col gap-2 items-center bg-black/60 p-3 rounded-xl border border-gray-700 backdrop-blur-md w-64 shadow-lg">
            <div class="flex justify-between w-full text-[10px] text-gray-400 font-bold mb-1">
                <span>Adjust Y-Axis</span>
                <span id="rotation-val" class="text-cyan-400">0¬∞</span>
            </div>
            <div class="flex items-center gap-3 w-full">
                <input type="range" id="rotation-slider" min="-180" max="180" value="0" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                <button onclick="resetRotation()" class="p-1.5 bg-gray-700 hover:bg-gray-600 text-white rounded-md transition border border-gray-500 shadow-sm" title="Reset to 0">
                    <i data-lucide="rotate-ccw" width="14" height="14"></i>
                </button>
            </div>
        </div>

        <!-- 3. Builder Mode UI -->
        <div id="builder-ui" class="ui-overlay inset-0 flex-col pointer-events-none bg-black/20">
            <!-- Builder Top Bar -->
            <div class="w-full bg-black/80 backdrop-blur p-4 flex justify-between items-center pointer-events-auto border-b border-gray-700">
                <div class="text-white">
                    <h2 class="font-bold text-lg md:text-xl text-green-400 flex gap-2 items-center"><i data-lucide="hammer" class="w-5 h-5"></i> Builder</h2>
                </div>
                <div class="flex gap-2">
                    <button onclick="exitBuilderMode()" class="px-3 py-1.5 md:px-4 md:py-2 rounded bg-gray-700 hover:bg-gray-600 text-white text-xs md:text-sm">Cancel</button>
                    <button onclick="saveCustomLevel()" class="px-4 py-1.5 md:px-6 md:py-2 rounded bg-green-600 hover:bg-green-500 text-white font-bold text-xs md:text-sm shadow-[0_0_10px_rgba(34,197,94,0.4)]">Save</button>
                </div>
            </div>

            <!-- Builder Tools -->
            <div class="absolute top-20 left-1/2 transform -translate-x-1/2 bg-black/80 backdrop-blur p-2 rounded-xl border border-gray-700 flex gap-2 pointer-events-auto shadow-xl">
                <button onclick="setBuilderTool('ROTATE')" id="btn-tool-rotate" class="tool-btn active flex flex-col items-center justify-center w-16 h-14 md:w-20 md:h-16 rounded-lg bg-gray-800 hover:bg-gray-700 border border-gray-600 transition">
                    <i data-lucide="move-3d"></i>
                    <span class="text-[9px] md:text-[10px] mt-1 font-bold">ROTATE</span>
                </button>
                <button onclick="setBuilderTool('ADD')" id="btn-tool-add" class="tool-btn flex flex-col items-center justify-center w-16 h-14 md:w-20 md:h-16 rounded-lg bg-gray-800 hover:bg-gray-700 border border-gray-600 transition">
                    <i data-lucide="plus-square"></i>
                    <span class="text-[9px] md:text-[10px] mt-1 font-bold">ADD</span>
                </button>
                <button onclick="setBuilderTool('DELETE')" id="btn-tool-delete" class="tool-btn flex flex-col items-center justify-center w-16 h-14 md:w-20 md:h-16 rounded-lg bg-gray-800 hover:bg-gray-700 border border-gray-600 transition">
                    <i data-lucide="trash-2"></i>
                    <span class="text-[9px] md:text-[10px] mt-1 font-bold">DELETE</span>
                </button>
            </div>

            <!-- Builder Bottom Bar -->
            <div class="mt-auto w-full p-4 flex justify-center pointer-events-auto pb-8">
                <div class="bg-black/80 backdrop-blur px-4 py-3 rounded-full border border-gray-700 flex gap-2 md:gap-4 w-full max-w-md">
                    <div class="flex items-center gap-2 text-white flex-grow">
                        <span class="text-xs md:text-sm text-gray-400 whitespace-nowrap">Name:</span>
                        <input type="text" id="level-name-input" class="bg-gray-800 border border-gray-600 rounded px-2 py-1 text-white text-xs md:text-sm focus:outline-none focus:border-green-500 w-full" placeholder="e.g. My Puzzle 1..." value="My Custom Level">
                    </div>
                    <div class="w-px bg-gray-600 mx-1"></div>
                    <button onclick="clearBuilder()" class="text-red-400 hover:text-red-300 text-xs md:text-sm flex items-center gap-1 whitespace-nowrap"><i data-lucide="trash-2" size="16"></i> Clear</button>
                </div>
            </div>
        </div>

        <!-- 4. Delete Confirmation Modal -->
        <div id="delete-modal" class="ui-overlay inset-0 flex items-center justify-center bg-black/70 backdrop-blur-sm z-50 hidden">
            <div class="bg-gray-900 border border-gray-700 p-6 rounded-xl shadow-2xl max-w-sm w-full mx-4 transform transition-all scale-100 pointer-events-auto">
                <div class="flex items-center gap-3 mb-4 text-red-400">
                    <div class="p-2 bg-red-900/30 rounded-full">
                        <i data-lucide="alert-triangle" size="24"></i>
                    </div>
                    <h3 class="text-xl font-bold text-white">Delete Level?</h3>
                </div>
                <p class="text-gray-300 mb-6 text-sm leading-relaxed">
                    Are you sure you want to delete this custom level? <br>
                    <span class="text-red-400 text-xs mt-1 block">This action cannot be undone.</span>
                </p>
                <div class="flex justify-end gap-3">
                    <button onclick="closeDeleteModal()" class="px-4 py-2 rounded-lg bg-gray-800 hover:bg-gray-700 text-white text-sm font-medium transition border border-gray-700">Cancel</button>
                    <button onclick="confirmDelete()" class="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-500 text-white text-sm font-bold shadow-lg shadow-red-900/20 transition flex items-center gap-2"><i data-lucide="trash-2" size="16"></i> Delete</button>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        lucide.createIcons();

        // --- GLOBAL STATE ---
        const MODE = { PLAY: 'PLAY', BUILD: 'BUILD' };
        let currentMode = MODE.PLAY;
        let webcamRunning = false;
        let handLandmarker = null;
        let lastVideoTime = -1;

        // Level Management (Updated to 5 levels)
        const defaultLevels = [
            { id: 1, name: "Level 1 (1x1)", difficulty: "Easy", color: "text-green-400", blocks: [{x:0, y:0, z:0}] },
            { id: 2, name: "Level 2 (2x1)", difficulty: "Easy", color: "text-green-400", blocks: [{x:0, y:0, z:0}, {x:1, y:0, z:0}] },
            { id: 3, name: "Level 3 (2x2)", difficulty: "Medium", color: "text-yellow-400", blocks: [{x:0, y:0, z:0}, {x:1, y:0, z:0}, {x:0, y:1, z:0}, {x:1, y:1, z:0}] },
            { id: 4, name: "Level 4 (Cube 2x2x2)", difficulty: "Hard", color: "text-orange-400", blocks: [
                {x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:1,z:0}, {x:1,y:1,z:0},
                {x:0,y:0,z:-1}, {x:1,y:0,z:-1}, {x:0,y:1,z:-1}, {x:1,y:1,z:-1}
            ]},
            { id: 5, name: "Level 5 (Cross)", difficulty: "Expert", color: "text-purple-400", blocks: [
                {x:1, y:0, z:0}, {x:1, y:1, z:0}, {x:1, y:2, z:0}, 
                {x:0, y:1, z:0}, {x:2, y:1, z:0}, {x:1, y:1, z:-1}
            ]}
        ];
        let customLevels = [];
        let allLevels = [];
        let currentLevelIndex = 0;
        let pendingDeleteIndex = -1;

        // 3D Variables
        let scene, camera, renderer;
        let cubeMesh, builderGroup;
        let orbitControls, raycaster, mouse;
        let gridHelper, plane, rollOverMesh;
        let builderBlocks = [];

        // Interaction State
        let manualRotationOffset = 0;
        let currentBuilderTool = 'ROTATE';
        let currentCountStep = 0;
        let sortedBlocksCache = [];
        
        // Smoothing
        const targetPos = new THREE.Vector3();
        const targetScale = new THREE.Vector3(0, 0, 0); 
        const targetQuaternion = new THREE.Quaternion();
        const lerpFactor = 0.05;

        // DOM References
        const video = document.getElementById('webcam');
        const canvas2D = document.getElementById('output_canvas');
        const ctx2D = canvas2D.getContext('2d');
        const canvas3D = document.getElementById('three_canvas');
        const statusText = document.getElementById('status-text');
        const statusEl = document.getElementById('status');
        const btnCam = document.getElementById('toggleCam');
        const btnText = document.getElementById('btn-text');

        // ================= INITIALIZATION =================
        async function init() {
            try {
                // 1. Data Setup
                loadCustomLevels();
                refreshLevelData();
                initMenu();

                // 2. 3D Setup
                initThreeJS();
                initBuilderTools();
                
                // 3. Start Level 0
                loadLevel(0);

                // 4. Start Render Loop
                requestAnimationFrame(renderLoop);

                // 5. Load AI (Async) - Start immediately
                setupAI();

            } catch (err) {
                console.error("Initialization Failed:", err);
                statusText.textContent = "System Error!";
                statusText.className = "text-red-500 font-bold";
            }
        }

        // ================= LEVEL SYSTEM =================
        function loadCustomLevels() {
            try {
                const saved = localStorage.getItem('ar_spatial_math_levels');
                if (saved) customLevels = JSON.parse(saved);
            } catch (e) {
                localStorage.removeItem('ar_spatial_math_levels');
                customLevels = [];
            }
        }

        function refreshLevelData() {
            allLevels = [...defaultLevels, ...customLevels];
        }

        // --- Delete Logic ---
        window.requestDeleteLevel = function(index) {
            pendingDeleteIndex = index;
            document.getElementById('delete-modal').classList.remove('hidden');
        };

        window.closeDeleteModal = function() {
            document.getElementById('delete-modal').classList.add('hidden');
            pendingDeleteIndex = -1;
        };

        window.confirmDelete = function() {
            if (pendingDeleteIndex === -1) return;
            customLevels.splice(pendingDeleteIndex, 1);
            localStorage.setItem('ar_spatial_math_levels', JSON.stringify(customLevels));
            refreshLevelData();
            initMenu();
            loadLevel(0);
            closeDeleteModal();
        };

        // ================= THREE.JS CORE =================
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            cubeMesh = new THREE.Group();
            cubeMesh.visible = false; 
            scene.add(cubeMesh);

            builderGroup = new THREE.Group();
            builderGroup.visible = false;
            scene.add(builderGroup);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x0088ff, 0.8);
            backLight.position.set(-5, -5, -10);
            scene.add(backLight);
        }

        function initBuilderTools() {
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.enabled = false;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            gridHelper.position.y = -0.5;
            builderGroup.add(gridHelper);

            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            planeGeometry.rotateX(-Math.PI / 2);
            plane = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ visible: false }));
            plane.position.y = -0.5;
            builderGroup.add(plane);

            const rollOverGeo = new THREE.BoxGeometry(1, 1, 1);
            const rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true, wireframe: true });
            rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
            rollOverMesh.visible = false;
            builderGroup.add(rollOverMesh);

            canvas3D.addEventListener('pointermove', onPointerMove);
            canvas3D.addEventListener('pointerdown', onPointerDown);
        }

        // ================= LEVEL LOADING =================
        function createBlock(x, y, z, isBuilder) {
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            const material = new THREE.MeshPhongMaterial({
                color: isBuilder ? 0x22c55e : 0xff8800,
                emissive: isBuilder ? 0x004400 : 0xaa4400,
                emissiveIntensity: 0.2,
                transparent: true, opacity: isBuilder ? 1.0 : 0.9, shininess: 80,
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData.isBlock = true;

            const outlineMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
            const outline = new THREE.Mesh(geometry, outlineMat);
            outline.scale.set(1.05, 1.05, 1.05);
            mesh.add(outline);

            const wireGeo = new THREE.EdgesGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const wire = new THREE.LineSegments(wireGeo, wireMat);
            mesh.add(wire);

            mesh.position.set(x, y, z);
            return mesh;
        }

        window.loadLevel = function(index) {
            if (index < 0 || index >= allLevels.length) index = 0;
            currentLevelIndex = index;
            const lvl = allLevels[index];

            while(cubeMesh.children.length > 0) cubeMesh.remove(cubeMesh.children[0]);

            if (lvl.blocks && lvl.blocks.length > 0) {
                let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity, minZ=Infinity, maxZ=-Infinity;
                lvl.blocks.forEach(b => {
                    minX = Math.min(minX, b.x); maxX = Math.max(maxX, b.x);
                    minY = Math.min(minY, b.y); maxY = Math.max(maxY, b.y);
                    minZ = Math.min(minZ, b.z); maxZ = Math.max(maxZ, b.z);
                });
                const cx = (minX + maxX) / 2;
                const cy = (minY + maxY) / 2;
                const cz = (minZ + maxZ) / 2;

                lvl.blocks.forEach(pos => {
                    cubeMesh.add(createBlock(pos.x - cx, pos.y - cy, pos.z - cz, false));
                });
            }

            document.querySelectorAll('.level-card').forEach((el, i) => {
                if(i === index) el.classList.add('active');
                else el.classList.remove('active');
            });
            
            resetCountingState();
        };

        // ================= AI & RENDER LOOP =================
        async function setupAI() {
            try {
                statusText.textContent = "Downloading Model...";
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                
                try {
                    handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numHands: 1
                    });
                } catch(e) {
                    console.warn("GPU init failed, falling back to CPU", e);
                    handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                            delegate: "CPU"
                        },
                        runningMode: "VIDEO",
                        numHands: 1
                    });
                }
                
                statusText.innerHTML = `<span class="text-green-400">‚óè AI Ready</span>`;
                statusEl.classList.remove("text-yellow-400");
                
                btnCam.disabled = false;
                btnCam.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-600');
                btnCam.classList.add('bg-gradient-to-r', 'from-blue-600', 'to-indigo-600');
                
                // FIX: Update btnCam.innerHTML directly to remove the spinner completely
                btnCam.innerHTML = `<i data-lucide="play-circle"></i> <span id="btn-text">Start Camera</span>`;
                lucide.createIcons();
                
            } catch (err) {
                console.error(err);
                statusText.textContent = "AI Load Failed";
                statusText.className = "text-red-500 font-bold";
            }
        }

        function runAI() {
            if (!handLandmarker || !webcamRunning || video.paused) return;

            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                try {
                    const results = handLandmarker.detectForVideo(video, performance.now());
                    ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);

                    if (results.landmarks && results.landmarks.length > 0) {
                        const landmarks = results.landmarks[0];
                        let isRightHand = true;
                        if (results.handedness?.[0]?.[0]) {
                            isRightHand = (results.handedness[0][0].categoryName === "Right");
                        }

                        const indexTip = landmarks[8];
                        const indexMCP = landmarks[5];
                        const screenX = (1 - indexTip.x) * 2 - 1; 
                        const screenY = -(indexTip.y * 2 - 1);
                        
                        const wrist = landmarks[0];
                        const middleMCP = landmarks[9];
                        const palmSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                        const zDepth = (palmSize * 15) - 4; 

                        // Calculate Position
                        const vector = new THREE.Vector3(screenX, screenY, 0.5);
                        vector.unproject(camera);
                        const dir = vector.sub(camera.position).normalize();
                        const distance = Math.abs((camera.position.z - zDepth) / dir.z);
                        const basePos = camera.position.clone().add(dir.multiplyScalar(distance));
                        
                        const vFingerY = new THREE.Vector3((1-indexTip.x)-(1-indexMCP.x), -(indexTip.y-indexMCP.y), -(indexTip.z-indexMCP.z)).normalize();
                        const offsetAmount = 1.2; 
                        const offsetVector = vFingerY.clone().multiplyScalar(offsetAmount);
                        
                        targetPos.copy(basePos).add(offsetVector);
                        targetScale.set(0.7, 0.7, 0.7);

                        // Calculate Rotation
                        const pinkyMCP = landmarks[17];
                        const vPalmX = new THREE.Vector3((1-pinkyMCP.x)-(1-indexMCP.x), -(pinkyMCP.y-indexMCP.y), -(pinkyMCP.z-indexMCP.z)).normalize();
                        let vZ = new THREE.Vector3().crossVectors(vPalmX, vFingerY).normalize();
                        if (isRightHand) vZ.negate();

                        const vX = new THREE.Vector3().crossVectors(vFingerY, vZ).normalize();
                        const rotationMatrix = new THREE.Matrix4();
                        rotationMatrix.makeBasis(vX, vFingerY, vZ);
                        targetQuaternion.setFromRotationMatrix(rotationMatrix);
                        
                        const yRotation = new THREE.Quaternion();
                        yRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), manualRotationOffset);
                        targetQuaternion.multiply(yRotation);

                        cubeMesh.visible = true;
                    } else {
                        targetScale.set(0, 0, 0); // Hide if lost
                    }
                } catch (e) {
                    console.error("Tracking Error:", e);
                }
            }
        }

        function renderLoop() {
            try {
                // Resize
                const width = window.innerWidth;
                const height = window.innerHeight;
                const needResize = canvas3D.width !== width * window.devicePixelRatio || canvas3D.height !== height * window.devicePixelRatio;
                if (needResize) {
                    renderer.setSize(width, height, false);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    canvas2D.width = width;
                    canvas2D.height = height;
                }

                if (currentMode === MODE.PLAY) {
                    if (webcamRunning) {
                        runAI();
                        cubeMesh.position.lerp(targetPos, lerpFactor);
                        cubeMesh.scale.lerp(targetScale, lerpFactor);
                        cubeMesh.quaternion.slerp(targetQuaternion, lerpFactor);
                    }
                    renderer.render(scene, camera);
                } else if (currentMode === MODE.BUILD) {
                    orbitControls.update();
                    renderer.render(scene, camera);
                }
            } catch (e) {
                // Ignore render errors to prevent crash
            }
            requestAnimationFrame(renderLoop);
        }

        // ================= BUILDER MODE CONTROLS =================
        window.startBuilderMode = function() {
            currentMode = MODE.BUILD;
            document.getElementById('level-menu').classList.remove('open');
            
            document.getElementById('play-ui').classList.add('opacity-0', 'pointer-events-none');
            document.getElementById('play-controls').classList.add('opacity-0', 'pointer-events-none');
            document.getElementById('rotation-controls').classList.add('opacity-0', 'pointer-events-none');
            document.getElementById('builder-ui').classList.add('active');
            canvas3D.style.cursor = 'default';

            if (webcamRunning) stopCam();
            video.style.opacity = 0;
            canvas2D.style.opacity = 0;
            
            cubeMesh.visible = false;
            builderGroup.visible = true;
            scene.background = new THREE.Color(0x111111);
            
            camera.position.set(5, 5, 8);
            camera.lookAt(0, 0, 0);
            
            clearBuilder();
            window.setBuilderTool('ROTATE');
        };

        window.exitBuilderMode = function() {
            currentMode = MODE.PLAY;
            
            document.getElementById('play-ui').classList.remove('opacity-0', 'pointer-events-none');
            document.getElementById('play-controls').classList.remove('opacity-0', 'pointer-events-none');
            document.getElementById('rotation-controls').classList.remove('opacity-0', 'pointer-events-none');
            document.getElementById('builder-ui').classList.remove('active');

            scene.background = null;
            builderGroup.visible = false;
            video.style.opacity = 1;
            canvas2D.style.opacity = 1;
            orbitControls.enabled = false;
            canvas3D.style.cursor = 'default';

            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
            
            // Explicitly hide mesh again to prevent initial ghosting
            cubeMesh.visible = false;
            
            loadLevel(currentLevelIndex);
        };

        window.setBuilderTool = function(tool) {
            currentBuilderTool = tool;
            
            document.getElementById('btn-tool-rotate').classList.toggle('active', tool === 'ROTATE');
            document.getElementById('btn-tool-add').classList.toggle('active', tool === 'ADD');
            document.getElementById('btn-tool-delete').classList.toggle('active', tool === 'DELETE');

            if (tool === 'ROTATE') {
                orbitControls.enabled = true;
                rollOverMesh.visible = false;
                canvas3D.style.cursor = 'grab';
            } else {
                orbitControls.enabled = false;
                rollOverMesh.visible = (tool === 'ADD');
                canvas3D.style.cursor = 'crosshair';
            }
        };

        function onPointerMove(event) {
            if (currentMode !== MODE.BUILD) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (currentBuilderTool === 'ADD') {
                const intersects = raycaster.intersectObjects([...builderBlocks, plane]);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    rollOverMesh.position.copy(intersect.point).add(intersect.face.normal).floor().addScalar(0.5);
                }
            }
        }

        function onPointerDown(event) {
            if (currentMode !== MODE.BUILD || event.button !== 0) return;
            if (currentBuilderTool === 'ROTATE') return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects([...builderBlocks, plane]);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                if (currentBuilderTool === 'ADD') {
                    const voxel = createBlock(0,0,0, true);
                    voxel.position.copy(intersect.point).add(intersect.face.normal).floor().addScalar(0.5);
                    builderGroup.add(voxel);
                    builderBlocks.push(voxel);
                } else if (currentBuilderTool === 'DELETE') {
                    if (intersect.object !== plane) {
                        builderGroup.remove(intersect.object);
                        builderBlocks.splice(builderBlocks.indexOf(intersect.object), 1);
                    }
                }
            }
        }

        window.clearBuilder = function() {
            builderBlocks.forEach(b => builderGroup.remove(b));
            builderBlocks = [];
        };

        window.saveCustomLevel = function() {
            if (builderBlocks.length === 0) {
                alert("Place at least 1 block!");
                return;
            }
            const name = document.getElementById('level-name-input').value.trim() || "Custom Level";
            const blocksData = builderBlocks.map(mesh => ({
                x: Math.round(mesh.position.x),
                y: Math.round(mesh.position.y),
                z: Math.round(mesh.position.z)
            }));
            
            const newLevel = {
                id: Date.now(),
                name: name,
                difficulty: "Custom",
                color: "text-blue-400",
                blocks: blocksData
            };
            
            customLevels.push(newLevel);
            localStorage.setItem('ar_spatial_math_levels', JSON.stringify(customLevels));
            
            refreshLevelData();
            initMenu();
            exitBuilderMode();
            loadLevel(allLevels.length - 1);
            document.getElementById('level-menu').classList.add('open');
        };

        window.deleteCustomLevel = function(customIndex) {
            if(confirm("Delete this level?")) {
                customLevels.splice(customIndex, 1);
                localStorage.setItem('ar_spatial_math_levels', JSON.stringify(customLevels));
                refreshLevelData();
                initMenu();
                if(currentLevelIndex >= allLevels.length) loadLevel(0);
            }
        };

        // ================= UI HELPERS =================
        function initMenu() {
            const list = document.getElementById('level-list');
            const customList = document.getElementById('custom-level-list');
            list.innerHTML = '';
            customList.innerHTML = '';

            defaultLevels.forEach((lvl, i) => list.appendChild(createLevelCard(lvl, i, false)));
            
            if (customLevels.length > 0) {
                customLevels.forEach((lvl, i) => customList.appendChild(createLevelCard(lvl, defaultLevels.length + i, true)));
            } else {
                customList.innerHTML = '<p class="text-xs text-gray-600 italic text-center py-2">No custom levels yet</p>';
            }
        }

        function createLevelCard(lvl, index, isCustom) {
            const card = document.createElement('div');
            card.className = `level-card bg-gray-900 p-3 rounded-lg cursor-pointer flex items-center gap-3 ${index === currentLevelIndex ? 'active' : ''}`;
            card.onclick = () => {
                if(currentMode === MODE.BUILD) exitBuilderMode();
                loadLevel(index);
                if(window.innerWidth < 768) document.getElementById('level-menu').classList.remove('open');
            };

            const cvs = document.createElement('canvas');
            cvs.width = 50; cvs.height = 50;
            cvs.className = "rounded bg-gray-800 border border-gray-700 flex-shrink-0";
            drawThumbnail(cvs, lvl.blocks);

            const info = document.createElement('div');
            info.className = "flex-grow min-w-0";
            info.innerHTML = `
                <div class="text-sm font-bold text-white truncate">${lvl.name}</div>
            `;
            
            card.appendChild(info);

            if (isCustom) {
                const delBtn = document.createElement('button');
                delBtn.className = "p-2 text-red-500 hover:text-red-400 z-10";
                delBtn.innerHTML = '<i data-lucide="trash"></i>';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    window.requestDeleteLevel(index - defaultLevels.length);
                };
                card.appendChild(delBtn);
            }
            return card;
        }

        function drawThumbnail(canvas, blocks) {
            const ctx = canvas.getContext('2d');
            const scale = 10;
            const cx = canvas.width/2;
            const cy = canvas.height/2 + 10;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = "#06b6d4";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            
            if(!blocks) return;
            const sorted = [...blocks].sort((a,b) => (a.z - b.z) || (a.y - b.y) || (a.x - b.x));
            sorted.forEach(b => {
                const isoX = (b.x - b.z) * scale * 0.8;
                const isoY = (b.x + b.z) * scale * 0.4 - (b.y * scale * 1.2);
                ctx.fillRect(cx + isoX - scale/2, cy + isoY - scale/2, scale, scale);
                ctx.strokeRect(cx + isoX - scale/2, cy + isoY - scale/2, scale, scale);
            });
        }

        // --- Counting Logic ---
        function getSortedBlocks() {
            if (!cubeMesh) return [];
            const blocks = cubeMesh.children.filter(c => c.userData.isBlock);
            return blocks.sort((a, b) => {
                if (Math.abs(a.position.y - b.position.y) > 0.1) return a.position.y - b.position.y;
                if (Math.abs(a.position.z - b.position.z) > 0.1) return a.position.z - b.position.z;
                return a.position.x - b.position.x;
            });
        }

        function setBlockColor(mesh, isHighlight) {
            mesh.material.color.setHex(isHighlight ? 0x3b82f6 : 0xff8800);
            mesh.material.emissive.setHex(isHighlight ? 0x1d4ed8 : 0xaa4400);
        }

        function resetCountingState() {
            currentCountStep = 0;
            sortedBlocksCache = getSortedBlocks();
            sortedBlocksCache.forEach(b => setBlockColor(b, false));
            const lvl = allLevels[currentLevelIndex];
            const qText = document.getElementById('question-text');
            if(lvl) {
                qText.innerText = `Level: ${lvl.name}`;
                qText.classList.remove('text-yellow-400');
            }
        }

        document.getElementById('countNextBtn').onclick = () => {
            if (currentCountStep < sortedBlocksCache.length) {
                const block = sortedBlocksCache[currentCountStep];
                setBlockColor(block, true);
                block.scale.multiplyScalar(1.2);
                setTimeout(() => block.scale.multiplyScalar(1/1.2), 150);
                currentCountStep++;
                if(currentCountStep === sortedBlocksCache.length) {
                    const qText = document.getElementById('question-text');
                    qText.innerText = `Answer: Total ${sortedBlocksCache.length} blocks`;
                    qText.classList.add('text-yellow-400');
                }
            }
        };

        document.getElementById('countPrevBtn').onclick = () => {
            if (currentCountStep > 0) {
                currentCountStep--;
                setBlockColor(sortedBlocksCache[currentCountStep], false);
                const lvl = allLevels[currentLevelIndex];
                const qText = document.getElementById('question-text');
                qText.innerText = `Level: ${lvl.name}`;
                qText.classList.remove('text-yellow-400');
            }
        };

        document.getElementById('resetStateBtn').onclick = resetCountingState;

        // --- Controls ---
        document.getElementById('rotation-slider').addEventListener('input', (e) => {
            const deg = parseInt(e.target.value);
            manualRotationOffset = deg * (Math.PI / 180);
            document.getElementById('rotation-val').innerText = `${deg}¬∞`;
        });

        window.resetRotation = () => {
            manualRotationOffset = 0;
            document.getElementById('rotation-slider').value = 0;
            document.getElementById('rotation-val').innerText = "0¬∞";
        };

        function stopCam() {
            webcamRunning = false;
            if(video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            // Use local btnCam for robustness
            const btnCam = document.getElementById('toggleCam');
            btnCam.innerHTML = `<i data-lucide="play-circle"></i> <span id="btn-text">Start Camera</span>`;
            btnCam.classList.replace('from-red-600', 'from-blue-600');
            btnCam.classList.replace('to-pink-600', 'to-indigo-600');
            
            if(cubeMesh) cubeMesh.visible = false;
            
            lucide.createIcons();
        }

        document.getElementById('toggleCam').addEventListener('click', () => {
            if (!handLandmarker) return;
            if (webcamRunning) {
                stopCam();
            } else {
                webcamRunning = true;
                const btnCam = document.getElementById('toggleCam');
                btnCam.innerHTML = `<i data-lucide="pause-circle"></i> <span id="btn-text">Pause</span>`;
                btnCam.classList.replace('from-blue-600', 'from-red-600');
                btnCam.classList.replace('to-indigo-600', 'to-pink-600');
                lucide.createIcons();
                
                navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                    video.srcObject = stream;
                });
            }
        });

        document.getElementById('toggleMenu').onclick = () => {
            document.getElementById('level-menu').classList.toggle('open');
        };

        // Boot
        init();

    </script>
</body>
</html>