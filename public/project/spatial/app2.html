<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Learning Hub</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;600;700&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { font-family: 'Sarabun', sans-serif; overflow: hidden; background-color: #020617; touch-action: none; color: white; }
        
        /* --- Shared Styles --- */
        .tech-font { font-family: 'Orbitron', sans-serif; }
        .glass-panel-dark {
            background: rgba(15, 23, 42, 0.85); /* Slate-900 with opacity */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid rgba(56, 189, 248, 0.2); /* Cyan border hint */
            box-shadow: 0 -4px 20px rgba(0,0,0,0.5);
        }

        .neon-slider { -webkit-appearance: none; width: 100%; background: transparent; }
        .neon-slider::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #06b6d4; /* Cyan-500 */
            border: 2px solid #fff;
            cursor: pointer; margin-top: -6px;
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.8);
            transition: transform 0.1s;
        }
        .neon-slider::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #334155; border-radius: 2px;
        }
        .neon-slider:active::-webkit-slider-thumb { transform: scale(1.2); }

        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* --- Shape Buttons --- */
        .shape-btn {
            background-color: #1e293b; /* Slate-800 */
            border: 1px solid #334155;
            color: #94a3b8;
            transition: all 0.2s;
        }
        .shape-btn.active {
            background-color: #0e7490; /* Cyan-700 */
            border-color: #22d3ee;
            color: #ffffff;
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.4);
        }

        /* --- Spatial Specific --- */
        #webcam, #output_canvas, #three_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        .mirror-mode { transform: scaleX(-1); }
        .ui-overlay { position: absolute; z-index: 20; pointer-events: none; }
        .ui-overlay > * { pointer-events: auto; } /* Allow clicks on children */

        #level-menu { transform: translateX(100%); transition: transform 0.3s ease; }
        #level-menu.open { transform: translateX(0); }
        
        .level-card { border: 1px solid transparent; }
        .level-card.active { 
            border-color: #06b6d4; box-shadow: 0 0 10px rgba(6,182,212,0.3); background: rgba(6,182,212,0.15); 
        }

        /* --- Home Card Animation --- */
        .home-card { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .home-card:hover { transform: translateY(-5px); box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5); border-color: #22d3ee; }

        /* --- Canvas Containers --- */
        #geo-canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }

        /* --- Geometric AI Preview --- */
        #geo-cam-preview {
            transition: opacity 0.3s, transform 0.3s;
        }
        #geo-cam-preview.hidden {
            opacity: 0; pointer-events: none; transform: scale(0.9);
        }
    </style>
</head>
<body>

    <!-- ================= HOME SCREEN ================= -->
    <div id="home-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-[#020617] text-white p-6 bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-slate-900 via-[#020617] to-black">
        <div class="text-center mb-12 relative z-10">
            <h1 class="text-4xl md:text-6xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 to-blue-500 tech-font drop-shadow-[0_0_10px_rgba(34,211,238,0.3)]">
                Math Learning Hub
            </h1>
            <p class="text-slate-400 text-lg">เลือกโหมดการเรียนรู้ที่คุณต้องการ</p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-4xl w-full relative z-10">
            <!-- Card 1: Geometric -->
            <button onclick="launchApp('geometric')" class="home-card group relative overflow-hidden bg-slate-800/50 border border-slate-700 rounded-2xl p-6 text-left hover:bg-slate-800/80 backdrop-blur-sm">
                <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-30 transition-opacity">
                    <i data-lucide="box" class="w-32 h-32 text-blue-400"></i>
                </div>
                <div class="relative z-10">
                    <div class="w-12 h-12 bg-blue-600 rounded-lg flex items-center justify-center mb-4 shadow-lg shadow-blue-500/30">
                        <i data-lucide="box" class="text-white w-6 h-6"></i>
                    </div>
                    <h2 class="text-2xl font-bold mb-2 text-white tech-font">Geometric Nets 3D</h2>
                    <p class="text-slate-400 text-sm">รูปคลี่เรขาคณิต 3 มิติ (Interactive)</p>
                </div>
            </button>

            <!-- Card 2: Spatial -->
            <button onclick="launchApp('spatial')" class="home-card group relative overflow-hidden bg-slate-800/50 border border-slate-700 rounded-2xl p-6 text-left hover:bg-slate-800/80 backdrop-blur-sm">
                <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-30 transition-opacity">
                    <i data-lucide="scan-face" class="w-32 h-32 text-cyan-400"></i>
                </div>
                <div class="relative z-10">
                    <div class="w-12 h-12 bg-cyan-600 rounded-lg flex items-center justify-center mb-4 shadow-lg shadow-cyan-500/30">
                        <i data-lucide="camera" class="text-white w-6 h-6"></i>
                    </div>
                    <h2 class="text-2xl font-bold mb-2 text-white tech-font">Spatial Math AR</h2>
                    <p class="text-slate-400 text-sm">มิติสัมพันธ์ผ่าน AI Webcam</p>
                </div>
            </button>
        </div>
        
        <!-- Background Effects -->
        <div class="absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none z-0">
            <div class="absolute top-1/4 left-1/4 w-96 h-96 bg-blue-500/10 rounded-full blur-3xl"></div>
            <div class="absolute bottom-1/4 right-1/4 w-96 h-96 bg-cyan-500/10 rounded-full blur-3xl"></div>
        </div>
    </div>


    <!-- ================= GEOMETRIC APP CONTAINER ================= -->
    <div id="geometric-app" class="hidden absolute inset-0 bg-[#0f172a]">
        
        <!-- Header Info -->
        <div class="absolute top-4 left-4 z-10 pointer-events-none">
            <h1 class="text-lg font-bold text-white drop-shadow-md tech-font">GEOMETRIC 3D</h1>
            <div class="flex items-center space-x-2 mt-1">
                <span id="currentShapeName" class="text-xs font-semibold text-cyan-300 bg-black/40 px-3 py-1 rounded-full border border-cyan-500/30 backdrop-blur-sm">
                    Cube
                </span>
            </div>
            <!-- AI Status Indicator -->
            <div id="geo-ai-status" class="hidden mt-2 flex items-center gap-2 px-3 py-1 bg-black/40 rounded-full border border-green-500/30 w-fit backdrop-blur-sm">
                <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                <span class="text-[10px] text-green-400 font-mono uppercase tracking-wide">AI Hand Control Active</span>
            </div>
        </div>

        <!-- NEW: Geometric AI Controls -->
        <div class="absolute top-4 right-16 z-40">
            <!-- Removed onclick="GeometricApp.toggleAI()" to prevent ReferenceError -->
             <button id="btn-geo-ai" class="p-2.5 bg-slate-800/80 hover:bg-slate-700 text-cyan-400 border border-cyan-500/30 rounded-lg backdrop-blur-md transition shadow-lg" title="Toggle Hand Control">
                <i data-lucide="camera" class="w-5 h-5"></i>
            </button>
        </div>

        <!-- NEW: Mini Webcam Preview -->
        <div id="geo-cam-preview" class="hidden absolute top-20 right-4 w-32 h-24 bg-black/90 rounded-xl border border-cyan-500/50 z-30 overflow-hidden shadow-2xl shadow-cyan-500/10">
            <video id="geo-webcam-video" class="w-full h-full object-cover mirror-mode" autoplay playsinline></video>
            <div class="absolute bottom-0 left-0 w-full bg-gradient-to-t from-black/80 to-transparent p-1">
                <p class="text-[8px] text-center text-slate-300">แบมือ = คลี่ / กำมือ = หุบ</p>
            </div>
        </div>

        <!-- Unified Top Right Controls -->
        <div class="absolute top-4 right-4 z-40 flex gap-2">
            <button onclick="exitApp()" class="p-2.5 bg-red-500/10 hover:bg-red-500/30 text-red-400 border border-red-500/30 rounded-lg backdrop-blur-md transition shadow-lg" title="Back to Home">
                <i data-lucide="log-out" class="w-5 h-5"></i>
            </button>
        </div>

        <!-- 3D Canvas -->
        <div id="geo-canvas-container"></div>

        <!-- Bottom Dock Controls -->
        <div class="fixed bottom-0 left-0 w-full z-30 glass-panel-dark rounded-t-2xl pb-safe transition-transform duration-300">
            <div class="px-5 pt-5 pb-8 max-w-xl mx-auto space-y-4">
                
                <!-- Sliders Row -->
                <div class="grid grid-cols-2 gap-6 items-center">
                    <!-- Zoom Slider -->
                    <div class="flex flex-col space-y-2">
                        <div class="flex justify-between text-[10px] font-bold text-slate-400 uppercase tracking-wider">
                            <span class="flex items-center gap-1"><i data-lucide="zoom-in" class="w-3 h-3"></i> Zoom</span>
                        </div>
                        <input type="range" id="zoomSlider" min="0" max="100" value="40" class="neon-slider">
                    </div>

                    <!-- Fold Slider -->
                    <div class="flex flex-col space-y-2 transition-opacity duration-200" id="foldControlGroup">
                        <div class="flex justify-between text-[10px] font-bold text-slate-400 uppercase tracking-wider">
                            <span class="flex items-center gap-1"><i data-lucide="fold-vertical" class="w-3 h-3"></i> Fold</span>
                            <span id="foldPercent" class="text-cyan-400 font-mono">100%</span>
                        </div>
                        <input type="range" id="foldSlider" min="0" max="100" value="100" class="neon-slider">
                    </div>
                </div>

                <!-- Divider -->
                <div class="h-px bg-slate-700/50 w-full"></div>

                <!-- Shape Selector -->
                <div class="flex space-x-3 overflow-x-auto hide-scrollbar py-1" id="shape-buttons-container">
                    <button data-shape="cube" class="shape-btn active flex-shrink-0 px-4 py-2 rounded-lg">
                        <span class="text-xs font-medium whitespace-nowrap">Cube</span>
                    </button>
                    <button data-shape="cuboid" class="shape-btn flex-shrink-0 px-4 py-2 rounded-lg">
                        <span class="text-xs font-medium whitespace-nowrap">Cuboid</span>
                    </button>
                    <button data-shape="cone" class="shape-btn flex-shrink-0 px-4 py-2 rounded-lg">
                        <span class="text-xs font-medium whitespace-nowrap">Cone</span>
                    </button>
                    <button data-shape="cylinder" class="shape-btn flex-shrink-0 px-4 py-2 rounded-lg">
                        <span class="text-xs font-medium whitespace-nowrap">Cylinder</span>
                    </button>
                    <button data-shape="pyramid" class="shape-btn flex-shrink-0 px-4 py-2 rounded-lg">
                        <span class="text-xs font-medium whitespace-nowrap">Pyramid</span>
                    </button>
                    <button data-shape="sphere" class="shape-btn flex-shrink-0 px-4 py-2 rounded-lg">
                        <span class="text-xs font-medium whitespace-nowrap">Sphere</span>
                    </button>
                </div>
            </div>
        </div>
    </div>


    <!-- ================= SPATIAL APP CONTAINER ================= -->
    <div id="spatial-app" class="hidden absolute inset-0 bg-black">
        
        <!-- Media Layers -->
        <video id="webcam" class="mirror-mode" autoplay playsinline></video>
        <canvas id="output_canvas" class="mirror-mode"></canvas>
        <canvas id="three_canvas"></canvas>

        <!-- Loading Screen -->
        <div id="loader" class="absolute inset-0 z-50 bg-black flex flex-col items-center justify-center">
            <div class="w-16 h-16 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-6"></div>
            <p class="text-cyan-400 tech-font animate-pulse tracking-widest">SYSTEM INITIALIZING...</p>
        </div>

        <!-- Top Left Info (Avoids overlapping controls) -->
        <div id="play-ui" class="ui-overlay top-4 left-4 max-w-[260px] md:max-w-xs bg-black/60 p-4 rounded-xl border border-cyan-500/30 backdrop-blur-md shadow-lg shadow-cyan-500/10">
            <h1 class="text-lg font-bold text-cyan-300 flex items-center gap-2 tech-font">
                <i data-lucide="scan-face" class="w-5 h-5"></i> SPATIAL AR
            </h1>
            <p class="text-white font-bold mt-1 truncate text-sm" id="current-level-name">Select a Level...</p>
            <p class="text-[10px] text-gray-400 mt-1 mb-3 flex items-center gap-1">
                <i data-lucide="hand" class="w-3 h-3"></i> Raise index finger to control
            </p>
            
            <!-- Counting Controls -->
            <div class="bg-slate-800/80 p-1.5 rounded-lg border border-slate-600 flex items-center justify-between gap-1">
                <button id="countPrevBtn" class="p-1.5 bg-slate-700 hover:bg-slate-600 rounded-md text-white transition">
                    <i data-lucide="chevron-left" class="w-4 h-4"></i>
                </button>
                <span class="text-gray-400 text-[10px] font-bold uppercase tracking-wider">COUNT</span>
                <button id="countNextBtn" class="p-1.5 bg-green-600 hover:bg-green-500 rounded-md text-white transition shadow-sm">
                    <i data-lucide="chevron-right" class="w-4 h-4"></i>
                </button>
                <div class="w-px h-5 bg-slate-600 mx-1"></div>
                <button id="resetStateBtn" class="p-1.5 bg-red-500/20 hover:bg-red-500/40 text-red-300 rounded-md transition" title="Reset">
                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                </button>
            </div>

            <!-- Status -->
            <div id="status" class="mt-2 text-[10px] flex items-center gap-2 text-yellow-400 font-mono">
                <div class="w-1.5 h-1.5 bg-yellow-400 rounded-full animate-pulse"></div>
                <span id="status-text">Loading Model...</span>
            </div>
        </div>

        <!-- Top Right Controls (Unified) -->
        <div class="ui-overlay top-4 right-4 flex gap-2">
            <!-- Menu Button -->
            <button id="toggleMenuBtn" class="p-2.5 bg-cyan-900/80 hover:bg-cyan-700 text-cyan-100 border border-cyan-500/50 rounded-lg backdrop-blur-md transition shadow-lg shadow-cyan-500/20">
                <i data-lucide="menu" class="w-5 h-5"></i>
            </button>
            <!-- Home Button -->
            <button onclick="exitApp()" class="p-2.5 bg-red-500/10 hover:bg-red-500/30 text-red-400 border border-red-500/30 rounded-lg backdrop-blur-md transition shadow-lg">
                <i data-lucide="log-out" class="w-5 h-5"></i>
            </button>
        </div>

        <!-- Level Menu (Right Sidebar) -->
        <div id="level-menu" class="absolute right-0 top-0 bottom-0 w-80 bg-slate-950/95 backdrop-blur-xl border-l border-slate-800 z-50 flex flex-col shadow-2xl">
            <div class="p-4 border-b border-slate-800 flex justify-between items-center h-[74px]">
                <h2 class="text-lg font-bold text-cyan-400 tech-font">LEVELS</h2>
                <button onclick="document.getElementById('level-menu').classList.remove('open')" class="text-slate-500 hover:text-white">
                    <i data-lucide="x"></i>
                </button>
            </div>
            
            <div class="p-2 overflow-y-auto flex-grow space-y-2 scrollbar-thin scrollbar-thumb-slate-700" id="level-list">
                <p class="text-center text-slate-500 text-sm mt-10">Waiting for data...</p>
            </div>

            <div class="p-4 border-t border-slate-800 bg-slate-900/50">
                <button id="refreshLevelsBtn" class="w-full py-2 bg-slate-800 hover:bg-slate-700 rounded text-sm text-cyan-400 font-bold flex justify-center gap-2 transition border border-slate-700">
                    <i data-lucide="refresh-cw" size="16"></i> Refresh List
                </button>
            </div>
        </div>

        <!-- Camera Control (Bottom Center) -->
        <div class="ui-overlay bottom-8 left-1/2 transform -translate-x-1/2 w-full flex justify-center px-4 pointer-events-none">
            <button id="toggleCam" disabled class="pointer-events-auto w-full max-w-[200px] px-4 py-3 bg-slate-700 cursor-not-allowed opacity-50 rounded-full hover:scale-105 transition shadow-[0_0_20px_rgba(79,70,229,0.3)] flex items-center justify-center gap-2 text-sm font-bold text-white border border-slate-600">
                <div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div> 
                <span id="btn-text">Loading AI...</span>
            </button>
        </div>

        <!-- Rotation Controls (Bottom Left - Desktop / Above Cam - Mobile) -->
        <div class="ui-overlay bottom-24 left-1/2 transform -translate-x-1/2 md:translate-x-0 md:left-4 md:bottom-8 bg-black/60 p-3 rounded-xl border border-slate-700 backdrop-blur-md w-64 shadow-lg flex flex-col gap-2">
            <div class="flex justify-between w-full text-[10px] text-slate-400 font-bold mb-1">
                <span>Rotate View (Y-Axis)</span>
                <span id="rotation-val" class="text-cyan-400">0°</span>
            </div>
            <div class="flex items-center gap-3 w-full">
                <input type="range" id="rotation-slider" min="-180" max="180" value="0" class="neon-slider">
                <button id="resetRotationBtn" class="p-1.5 bg-slate-700 hover:bg-slate-600 text-white rounded-md transition border border-slate-500 shadow-sm" title="Reset to 0">
                    <i data-lucide="rotate-ccw" width="14" height="14"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- MAIN SCRIPT -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        let activeAppName = null;
        lucide.createIcons();

        // ---------------------------------------------------------
        // GEOMETRIC APP LOGIC (AI Enhanced)
        // ---------------------------------------------------------
        const GeometricApp = {
            scene: null, camera: null, renderer: null, controls: null,
            currentShapeInstance: null, animationId: null, materials: null,
            sliderFold: null, sliderZoom: null, container: null,
            
            // AI Hand Control Props
            handLandmarker: null, webcamRunning: false, lastVideoTime: -1,
            geoVideo: null, aiToggleButton: null, targetFoldValue: 100,
            
            init: async function() {
                this.container = document.getElementById('geo-canvas-container');
                this.sliderFold = document.getElementById('foldSlider');
                this.sliderZoom = document.getElementById('zoomSlider');
                this.geoVideo = document.getElementById('geo-webcam-video');
                this.aiToggleButton = document.getElementById('btn-geo-ai');
                
                // Add event listener here instead of inline HTML
                if(this.aiToggleButton) {
                    this.aiToggleButton.onclick = () => this.toggleAI();
                }

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f172a); 

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                
                while(this.container.firstChild) this.container.removeChild(this.container.firstChild);
                this.container.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.enableZoom = false; 
                this.controls.minDistance = 2;
                this.controls.maxDistance = 50;
                this.controls.target.set(0, -1, 0); 
                this.camera.position.set(10, 10, 10);
                this.controls.update();

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
                dirLight.position.set(5, 10, 7);
                this.scene.add(dirLight);

                this.materials = {
                    face: new THREE.MeshPhongMaterial({
                        color: 0x3b82f6, 
                        transparent: true, opacity: 0.9, 
                        side: THREE.DoubleSide, flatShading: true,
                        shininess: 60,
                        emissive: 0x1d4ed8, emissiveIntensity: 0.2,
                        polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
                    }),
                    edge: new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 }) 
                };

                this.onWindowResize = this.onWindowResize.bind(this);
                window.addEventListener('resize', this.onWindowResize);
                
                this.onFoldInput = this.onFoldInput.bind(this);
                this.sliderFold.addEventListener('input', this.onFoldInput);
                
                this.onZoomInput = this.onZoomInput.bind(this);
                this.sliderZoom.addEventListener('input', this.onZoomInput);

                this.setupButtons();
                
                // Preload AI
                this.setupAI();

                this.animate = this.animate.bind(this);
                this.animate();
                this.setShape('cube');
            },

            setupAI: async function() {
                if (this.handLandmarker) return;
                try {
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                    this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                        runningMode: "VIDEO", numHands: 1
                    });
                    console.log("Geometric AI Ready");
                    if(this.aiToggleButton) {
                        this.aiToggleButton.classList.add('animate-pulse', 'border-cyan-400'); // Indicate ready
                        setTimeout(() => this.aiToggleButton.classList.remove('animate-pulse', 'border-cyan-400'), 2000);
                    }
                } catch(e) {
                    console.error("AI Load Failed", e);
                }
            },

            toggleAI: async function() {
                if (!this.handLandmarker) {
                    alert("AI System is loading, please wait...");
                    return;
                }
                
                if (this.webcamRunning) {
                    // Stop AI
                    this.webcamRunning = false;
                    const preview = document.getElementById('geo-cam-preview');
                    const status = document.getElementById('geo-ai-status');
                    const btn = document.getElementById('btn-geo-ai');
                    
                    preview.classList.add('hidden');
                    status.classList.add('hidden');
                    btn.classList.remove('bg-cyan-600', 'text-white');
                    btn.classList.add('text-cyan-400', 'bg-slate-800/80');

                    if(this.geoVideo.srcObject) {
                        this.geoVideo.srcObject.getTracks().forEach(t => t.stop());
                        this.geoVideo.srcObject = null;
                    }
                } else {
                    // Start AI
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                        this.geoVideo.srcObject = stream;
                        this.webcamRunning = true;
                        
                        document.getElementById('geo-cam-preview').classList.remove('hidden');
                        document.getElementById('geo-ai-status').classList.remove('hidden');
                        const btn = document.getElementById('btn-geo-ai');
                        btn.classList.add('bg-cyan-600', 'text-white');
                        btn.classList.remove('text-cyan-400', 'bg-slate-800/80');

                    } catch(e) {
                        console.error("Cam access denied", e);
                        alert("Camera access required for Hand Control");
                    }
                }
            },

            processAI: function() {
                if(!this.handLandmarker || !this.webcamRunning || !this.geoVideo.videoWidth) return;
                
                if (this.lastVideoTime !== this.geoVideo.currentTime) {
                    this.lastVideoTime = this.geoVideo.currentTime;
                    const results = this.handLandmarker.detectForVideo(this.geoVideo, performance.now());
                    
                    if (results.landmarks && results.landmarks.length > 0) {
                        const marks = results.landmarks[0];
                        // Calculate Hand Openness
                        // Wrist = 0, Middle Finger Tip = 12, Middle MCP (Knuckle) = 9
                        // Measure average distance of tips to wrist vs palm size
                        
                        const wrist = marks[0];
                        const palmSize = Math.hypot(marks[9].x - wrist.x, marks[9].y - wrist.y);
                        
                        // Tips: Index(8), Middle(12), Ring(16), Pinky(20)
                        const tips = [8, 12, 16, 20];
                        let avgTipDist = 0;
                        tips.forEach(i => {
                            avgTipDist += Math.hypot(marks[i].x - wrist.x, marks[i].y - wrist.y);
                        });
                        avgTipDist /= 4;

                        // Ratio: > 1.5 usually open, < 0.8 usually fist
                        const ratio = avgTipDist / palmSize;
                        
                        // Map Ratio to Fold Slider
                        // Fist (Closed) -> Ratio Low -> Fold 100%
                        // Open Hand -> Ratio High -> Fold 0%
                        
                        // Clamp ratio roughly between 0.8 (fist) and 1.8 (open)
                        let normalized = (ratio - 0.8) / (1.8 - 0.8);
                        normalized = Math.max(0, Math.min(1, normalized)); // 0 = Fist, 1 = Open
                        
                        // If Open (1), we want Slider 0 (Unfold/Net)
                        // If Fist (0), we want Slider 100 (Fold/Shape)
                        const targetVal = (1 - normalized) * 100;
                        
                        // Smooth Lerp
                        const currentVal = parseFloat(this.sliderFold.value);
                        const newVal = currentVal + (targetVal - currentVal) * 0.15;
                        
                        this.sliderFold.value = newVal;
                        this.onFoldInput({ target: { value: newVal } }); // Trigger update
                    }
                }
            },

            dispose: function() {
                if (this.animationId) cancelAnimationFrame(this.animationId);
                window.removeEventListener('resize', this.onWindowResize);
                if(this.sliderFold) this.sliderFold.removeEventListener('input', this.onFoldInput);
                if(this.sliderZoom) this.sliderZoom.removeEventListener('input', this.onZoomInput);
                
                // Clear button handler
                if(this.aiToggleButton) this.aiToggleButton.onclick = null;

                // Stop Webcam if running
                if(this.webcamRunning) {
                    this.toggleAI();
                }

                if (this.renderer && this.container) this.container.removeChild(this.renderer.domElement);
                this.scene = null; this.camera = null; this.renderer = null; this.controls = null;
            },

            animate: function() {
                this.animationId = requestAnimationFrame(this.animate);
                
                // AI Update Loop
                if(this.webcamRunning) {
                    this.processAI();
                }

                if (this.controls) this.controls.update();
                if (this.renderer && this.scene && this.camera) this.renderer.render(this.scene, this.camera);
            },

            onWindowResize: function() {
                if (!this.camera || !this.renderer) return;
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            },

            onFoldInput: function(e) {
                const val = parseInt(e.target.value);
                document.getElementById('foldPercent').textContent = `${val}%`;
                if (this.currentShapeInstance) this.currentShapeInstance.update(val / 100);
            },

            onZoomInput: function(e) { this.updateZoom(parseInt(e.target.value)); },

            updateZoom: function(val) {
                if (!this.camera || !this.controls) return;
                const minD = 5; const maxD = 40;
                const dist = maxD - (val/100 * (maxD - minD));
                const dir = new THREE.Vector3().copy(this.camera.position).sub(this.controls.target).normalize();
                this.camera.position.copy(this.controls.target).add(dir.multiplyScalar(dist));
                this.camera.updateProjectionMatrix();
            },

            setupButtons: function() {
                const btns = document.querySelectorAll('.shape-btn');
                btns.forEach(btn => {
                    btn.onclick = () => {
                        const shape = btn.getAttribute('data-shape');
                        this.setShape(shape);
                    };
                });
            },

            setShape: function(type) {
                if (this.currentShapeInstance) {
                    this.scene.remove(this.currentShapeInstance.root);
                    this.currentShapeInstance = null;
                }
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                const activeBtn = document.querySelector(`.shape-btn[data-shape="${type}"]`);
                if(activeBtn) activeBtn.classList.add('active');

                // Re-declare Factory Logic locally to use `this` context
                const ShapeFactory = {
                    cube: { name: 'ลูกบาศก์ (Cube)', fn: this.createCube.bind(this) },
                    cuboid: { name: 'ทรงสี่เหลี่ยมมุมฉาก (Cuboid)', fn: this.createCuboid.bind(this) },
                    cone: { name: 'ทรงกรวย (Cone)', fn: this.createCone.bind(this) },
                    cylinder: { name: 'ทรงกระบอก (Cylinder)', fn: this.createCylinder.bind(this) },
                    pyramid: { name: 'พีระมิด (Pyramid)', fn: this.createPyramid.bind(this) },
                    sphere: { name: 'ทรงกลม (Sphere)', fn: this.createSphere.bind(this), noFold: true }
                };
                
                const shapeData = ShapeFactory[type];
                document.getElementById('currentShapeName').textContent = shapeData.name;
                this.currentShapeInstance = shapeData.fn();
                this.scene.add(this.currentShapeInstance.root);

                this.sliderFold.value = 100;
                document.getElementById('foldPercent').textContent = '100%';
                const foldGroup = document.getElementById('foldControlGroup');

                if (shapeData.noFold) {
                    foldGroup.style.opacity = '0'; foldGroup.style.pointerEvents = 'none';
                } else {
                    foldGroup.style.opacity = '1'; foldGroup.style.pointerEvents = 'auto';
                    this.currentShapeInstance.update(1);
                }
                this.controls.reset();
                this.controls.target.set(0, -1, 0); 
                this.camera.position.set(10, 10, 10);
                this.camera.lookAt(0, -1, 0);
                this.sliderZoom.value = 40;
                this.updateZoom(40);
            },

            // --- Shapes (Copied Logic, updated context) ---
            createCube: function() {
                const root = new THREE.Group();
                const SIDE = 4; const HALF = SIDE/2; const pivots = []; const mats = this.materials;
                function makeFace() {
                    const g = new THREE.PlaneGeometry(SIDE, SIDE); const m = new THREE.Mesh(g, mats.face);
                    m.rotation.x = -Math.PI/2; m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), mats.edge)); return m;
                }
                function addPivot(px, py, pz, offX, offZ, axis, dir, parent=root) {
                    const piv = new THREE.Group(); piv.position.set(px, py, pz); parent.add(piv);
                    const mesh = makeFace(); mesh.position.set(offX, 0, offZ); piv.add(mesh);
                    pivots.push({ group: piv, axis, dir }); return piv;
                }
                root.add(makeFace());
                addPivot(HALF, 0, 0, HALF, 0, 'z', 1); addPivot(-HALF, 0, 0, -HALF, 0, 'z', -1);
                addPivot(0, 0, HALF, 0, HALF, 'x', -1); const back = addPivot(0, 0, -HALF, 0, -HALF, 'x', 1);
                addPivot(0, 0, -SIDE, 0, -HALF, 'x', 1, back);
                return { root, update: (t) => { const angle = t * (Math.PI/2); pivots.forEach(p => p.group.rotation[p.axis] = angle * p.dir); } };
            },
            createCuboid: function() {
                const root = new THREE.Group();
                const DX=5, DZ=3, DY=2; const pivots = []; const mats = this.materials;
                function makeRect(w, d) {
                    const g = new THREE.PlaneGeometry(w, d); const m = new THREE.Mesh(g, mats.face);
                    m.rotation.x = -Math.PI/2; m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), mats.edge)); return m;
                }
                function addPivot(px, py, pz, offX, offZ, w, d, axis, dir, parent=root) {
                    const piv = new THREE.Group(); piv.position.set(px, py, pz); parent.add(piv);
                    const mesh = makeRect(w, d); mesh.position.set(offX, 0, offZ); piv.add(mesh);
                    pivots.push({ group: piv, axis, dir }); return piv;
                }
                root.add(makeRect(DX, DZ));
                addPivot(DX/2, 0, 0, DY/2, 0, DY, DZ, 'z', 1); addPivot(-DX/2, 0, 0, -DY/2, 0, DY, DZ, 'z', -1);
                addPivot(0, 0, DZ/2, 0, DY/2, DX, DY, 'x', -1); const back = addPivot(0, 0, -DZ/2, 0, -DY/2, DX, DY, 'x', 1);
                addPivot(0, 0, -DY, 0, -DZ/2, DX, DZ, 'x', 1, back);
                return { root, update: (t) => { const angle = t * (Math.PI/2); pivots.forEach(p => p.group.rotation[p.axis] = angle * p.dir); } };
            },
            createCone: function() {
                const root = new THREE.Group(); root.position.y = 0.01;
                const R = 2.5, S = 6; const H = Math.sqrt(S*S - R*R); const SEGS = 60;
                const SEG_ANGLE = 2 * Math.asin((R/S) * Math.sin(Math.PI/SEGS));
                const BEND_ANGLE = 2 * Math.asin(Math.sin(Math.PI/SEGS) * (H/S));
                const TARGET_LIFT = Math.PI - Math.atan2(H, R);
                const baseGeo = new THREE.CircleGeometry(R, SEGS); baseGeo.rotateX(-Math.PI/2).rotateY(-Math.PI/2);
                const base = new THREE.Mesh(baseGeo, new THREE.MeshPhongMaterial({color: 0x2563eb, side:THREE.DoubleSide, transparent:true, opacity:0.85}));
                base.add(new THREE.LineSegments(new THREE.EdgesGeometry(baseGeo), new THREE.LineBasicMaterial({color: 0x60a5fa})));
                root.add(base);
                const lifter = new THREE.Group(); const anchor = new THREE.Group(); anchor.position.x = -R; anchor.add(lifter); root.add(anchor);
                const tipNode = new THREE.Group(); tipNode.position.x = -S; lifter.add(tipNode);
                const jointsF = [], jointsB = []; const mats = this.materials;
                function buildChain(parent, count, isFront) {
                    let curr = parent;
                    for(let i=0; i<count; i++) {
                        const piv = new THREE.Group(); curr.add(piv);
                        const shape = new THREE.Shape(); shape.moveTo(0,0); shape.lineTo(S,0);
                        shape.lineTo(S*Math.cos(SEG_ANGLE), S*Math.sin(SEG_ANGLE)*(isFront?-1:1)); shape.lineTo(0,0);
                        const geo = new THREE.ShapeGeometry(shape); geo.rotateX(-Math.PI/2);
                        const mesh = new THREE.Mesh(geo, mats.face); piv.add(mesh);
                        const next = new THREE.Group(); next.rotation.y = SEG_ANGLE * (isFront ? 1 : -1); piv.add(next);
                        (isFront ? jointsF : jointsB).push(piv); curr = next;
                    }
                }
                buildChain(tipNode, SEGS/2, true); buildChain(tipNode, SEGS/2, false);
                return { root, update: (t) => { const ease = t*t*(3-2*t); lifter.rotation.z = -ease * TARGET_LIFT; const bend = ease * BEND_ANGLE; jointsF.forEach(j => j.rotation.x = bend); jointsB.forEach(j => j.rotation.x = -bend); } };
            },
            createCylinder: function() {
                const root = new THREE.Group(); const R=2, H=5, SEGS = 36; const W = (2*Math.PI*R)/SEGS;
                const jointsR=[], jointsL=[], caps=[]; const mats = this.materials;
                function makeStrip() { const g = new THREE.PlaneGeometry(W, H); const m = new THREE.Mesh(g, mats.face); m.rotation.x = -Math.PI/2; return m; }
                function buildChain(parent, count, dir, arr) {
                    let curr = parent;
                    for(let i=0; i<count; i++) {
                        const piv = new THREE.Group(); piv.position.set(i===0?0:(dir*W), 0, 0); curr.add(piv);
                        const m = makeStrip(); m.position.set(dir*W/2, 0, 0); piv.add(m); arr.push(piv); curr = piv;
                    }
                }
                buildChain(root, SEGS/2, 1, jointsR); buildChain(root, SEGS/2, -1, jointsL);
                const topPiv = new THREE.Group(); topPiv.position.z = -H/2; root.add(topPiv);
                const topCap = new THREE.Mesh(new THREE.CircleGeometry(R, 32).rotateX(-Math.PI/2), mats.face); topCap.position.z = -R; topPiv.add(topCap); caps.push({g:topPiv, d:1});
                const botPiv = new THREE.Group(); botPiv.position.z = H/2; root.add(botPiv);
                const botCap = new THREE.Mesh(new THREE.CircleGeometry(R, 32).rotateX(-Math.PI/2), mats.face); botCap.position.z = R; botPiv.add(botCap); caps.push({g:botPiv, d:-1});
                const MAX_JOINT = (Math.PI*2)/SEGS;
                return { root, update: (t) => { const ease = t*t*(3-2*t); caps.forEach(c => c.g.rotation.x = ease * (Math.PI/2) * c.d); const jointRot = ease * MAX_JOINT; const baseRot = ease * (MAX_JOINT/2); jointsR.forEach((j,i) => j.rotation.z = (i===0?baseRot:jointRot)); jointsL.forEach((j,i) => j.rotation.z = -(i===0?baseRot:jointRot)); } };
            },
            createPyramid: function() {
                const root = new THREE.Group(); const B=4, H=4, HB=2; const MAX_FOLD = Math.PI - Math.acos(HB/H); const pivots = []; const mats = this.materials;
                const base = new THREE.Mesh(new THREE.PlaneGeometry(B,B).rotateX(-Math.PI/2), mats.face); base.add(new THREE.LineSegments(new THREE.EdgesGeometry(base.geometry), mats.edge)); root.add(base);
                function makeTri(v1, v2, v3) {
                    const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(new Float32Array([...v1,...v2,...v3]), 3));
                    g.computeVertexNormals(); const m = new THREE.Mesh(g, mats.face); m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), mats.edge)); return m;
                }
                function addSide(px, py, pz, axis, dir, vTip) {
                    const piv = new THREE.Group(); piv.position.set(px, py, pz); root.add(piv);
                    let c1, c2; if(axis==='z') { c1=[0,0,-HB]; c2=[0,0,HB]; } else { c1=[HB,0,0]; c2=[-HB,0,0]; }
                    const m = makeTri(c1, c2, vTip); piv.add(m); pivots.push({group:piv, axis, dir});
                }
                addSide(HB,0,0, 'z', 1, [H,0,0]); addSide(-HB,0,0, 'z', -1, [-H,0,0]); addSide(0,0,-HB, 'x', 1, [0,0,-H]); addSide(0,0,HB, 'x', -1, [0,0,H]);
                return { root, update: (t) => { const a = t * MAX_FOLD; pivots.forEach(p => p.group.rotation[p.axis] = a * p.dir); } };
            },
            createSphere: function() {
                const root = new THREE.Group(); const geo = new THREE.SphereGeometry(3, 64, 64);
                const mat = new THREE.MeshPhongMaterial({color: 0x3b82f6, transparent:true, opacity:0.9, shininess:60});
                const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 3; root.add(mesh);
                const sg = new THREE.CircleGeometry(3.5, 32).rotateX(-Math.PI/2); const sm = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.3});
                const s = new THREE.Mesh(sg, sm); s.position.y = 0.05; root.add(s);
                return { root, update: (t) => {} };
            }
        };

        // ---------------------------------------------------------
        // SPATIAL APP LOGIC
        // ---------------------------------------------------------
        const SpatialUtils = {
            COLORS: {
                block: 0xff8800, blockEmissive: 0xaa4400,
                builderBlock: 0x22c55e, builderEmissive: 0x004400,
                highlight: 0x06b6d4, highlightEmissive: 0x0891b2
            },
            createBlockMesh: function(x, y, z, isBuilder = false) {
                const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
                const material = new THREE.MeshPhongMaterial({
                    color: isBuilder ? this.COLORS.builderBlock : this.COLORS.block,
                    emissive: isBuilder ? this.COLORS.builderEmissive : this.COLORS.blockEmissive,
                    emissiveIntensity: 0.3,
                    transparent: true, opacity: isBuilder ? 1.0 : 0.9, shininess: 80,
                });
                const mesh = new THREE.Mesh(geometry, material); mesh.userData.isBlock = true;
                const outlineMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
                const outline = new THREE.Mesh(geometry, outlineMat); outline.scale.set(1.05, 1.05, 1.05); mesh.add(outline);
                const wireGeo = new THREE.EdgesGeometry(geometry);
                const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                const wire = new THREE.LineSegments(wireGeo, wireMat); mesh.add(wire);
                mesh.position.set(x, y, z);
                return mesh;
            }
        };

        const SpatialApp = {
            handLandmarker: null, webcamRunning: false, lastVideoTime: -1,
            levels: [], currentLevel: null, scene: null, camera: null, renderer: null, cubeGroup: null, animationId: null,
            targetPos: new THREE.Vector3(), targetScale: new THREE.Vector3(0, 0, 0), targetQuaternion: new THREE.Quaternion(),
            lerpFactor: 0.08, manualRotationOffset: 0, sortedBlocksCache: [], currentCountStep: 0,
            db: null, auth: null, appId: 'default-app',
            video: null, canvas2D: null, ctx2D: null, statusText: null, statusEl: null, btnCam: null,

            init: async function() {
                this.video = document.getElementById('webcam');
                this.canvas2D = document.getElementById('output_canvas');
                this.ctx2D = this.canvas2D.getContext('2d');
                this.statusText = document.getElementById('status-text');
                this.statusEl = document.getElementById('status');
                this.btnCam = document.getElementById('toggleCam');

                this.initThreeJS();
                this.setupEventListeners();

                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
                    apiKey: "AIzaSyAlfZHbCFxGK3p3nDoAPy3m9KqZzmX2s9I",
                    authDomain: "kruboat-web.firebaseapp.com",
                    projectId: "kruboat-web",
                    storageBucket: "kruboat-web.firebasestorage.app",
                    messagingSenderId: "61868765546",
                    appId: "1:61868765546:web:683b18ddf68c89dd317513"
                };
                const app = initializeApp(firebaseConfig);
                this.db = getFirestore(app);
                this.auth = getAuth(app);
                this.appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';

                // Robust Auth & Data Loading with Timeout
                const loadData = async () => {
                    return new Promise(async (resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject('Timeout');
                        }, 3000); // 3 seconds timeout

                        try {
                            await signInAnonymously(this.auth);
                            await this.refreshLevels();
                            clearTimeout(timeout);
                            resolve();
                        } catch (e) {
                            clearTimeout(timeout);
                            reject(e);
                        }
                    });
                };

                try {
                    await loadData();
                } catch (e) {
                    console.warn("Using offline mode due to:", e);
                    this.loadOfflineLevels();
                } finally {
                    // Guaranteed to hide loader
                    const loader = document.getElementById('loader');
                    if(loader) loader.style.display = 'none';
                }

                await this.setupAI();
                this.animate = this.animate.bind(this);
                this.animate();
                window.dispatchEvent(new Event('resize'));
            },

            loadOfflineLevels: function() {
                this.levels = [
                    {
                        id: 'off-1', name: 'Start Cube (Offline)', difficulty: 'Easy',
                        blocks: [{x:0, y:0, z:0}, {x:0, y:1, z:0}, {x:1, y:0, z:0}]
                    },
                    {
                        id: 'off-2', name: 'The Bridge (Offline)', difficulty: 'Medium',
                        blocks: [{x:-1, y:0, z:0}, {x:0, y:0, z:0}, {x:1, y:0, z:0}, {x:0, y:1, z:0}]
                    }
                ];
                this.renderLevelList();
                // Auto load first level
                if(this.levels.length > 0) {
                     // Find card and act like click
                     setTimeout(() => {
                         const firstCard = document.querySelector('.level-card');
                         if(firstCard) this.loadLevel(this.levels[0], firstCard);
                     }, 500);
                }
            },

            dispose: function() {
                if (this.animationId) cancelAnimationFrame(this.animationId);
                this.webcamRunning = false;
                if(this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(t => t.stop());
                    this.video.srcObject = null;
                }
                if(this.ctx2D) this.ctx2D.clearRect(0,0, this.canvas2D.width, this.canvas2D.height);
                this.btnCam.innerHTML = `Loading...`;
                this.btnCam.classList.add('bg-slate-700', 'cursor-not-allowed', 'opacity-50');
            },

            initThreeJS: function() {
                const canvas = document.getElementById('three_canvas');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 5);

                this.renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(5, 10, 7);
                this.scene.add(dirLight);
                const backLight = new THREE.DirectionalLight(0x0088ff, 0.8);
                backLight.position.set(-5, -5, -10);
                this.scene.add(backLight);

                this.cubeGroup = new THREE.Group();
                this.cubeGroup.visible = false;
                this.scene.add(this.cubeGroup);
            },

            setupEventListeners: function() {
                window.addEventListener('resize', () => {
                    if(!this.camera || !this.renderer) return;
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    this.renderer.setSize(width, height);
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    if(this.canvas2D) {
                        this.canvas2D.width = width;
                        this.canvas2D.height = height;
                    }
                });

                document.getElementById('toggleMenuBtn').onclick = () => document.getElementById('level-menu').classList.toggle('open');
                document.getElementById('refreshLevelsBtn').onclick = () => this.refreshLevels();

                const rotSlider = document.getElementById('rotation-slider');
                const rotVal = document.getElementById('rotation-val');
                rotSlider.oninput = (e) => {
                    const deg = parseInt(e.target.value);
                    this.manualRotationOffset = deg * (Math.PI / 180);
                    rotVal.innerText = `${deg}°`;
                };
                document.getElementById('resetRotationBtn').onclick = () => {
                    this.manualRotationOffset = 0;
                    rotSlider.value = 0;
                    rotVal.innerText = "0°";
                };

                document.getElementById('countNextBtn').onclick = () => this.handleCount(1);
                document.getElementById('countPrevBtn').onclick = () => this.handleCount(-1);
                document.getElementById('resetStateBtn').onclick = () => this.resetCountingState();
                this.btnCam.onclick = () => this.toggleCamera();
            },

            setupAI: async function() {
                if (this.handLandmarker) {
                    this.enableCamUI();
                    return;
                }
                try {
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                    try {
                        this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                            runningMode: "VIDEO", numHands: 1
                        });
                    } catch(e) {
                        this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                            baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "CPU" },
                            runningMode: "VIDEO", numHands: 1
                        });
                    }
                    this.enableCamUI();
                } catch (err) {
                    console.error(err);
                    this.statusText.textContent = "AI Error"; this.statusText.className = "text-red-500 font-bold";
                }
            },

            enableCamUI: function() {
                this.statusText.innerHTML = `<span class="text-green-400">● AI Ready</span>`;
                this.statusEl.classList.remove("text-yellow-400");
                this.btnCam.disabled = false;
                this.btnCam.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-slate-700');
                this.btnCam.classList.add('bg-gradient-to-r', 'from-blue-600', 'to-cyan-600');
                this.btnCam.innerHTML = `<i data-lucide="play-circle"></i> <span id="btn-text">Start Camera</span>`;
                lucide.createIcons();
            },

            toggleCamera: function() {
                if (!this.handLandmarker) return;
                if (this.webcamRunning) {
                    this.webcamRunning = false;
                    if(this.video.srcObject) this.video.srcObject.getTracks().forEach(t => t.stop());
                    this.video.srcObject = null;
                    this.btnCam.innerHTML = `<i data-lucide="play-circle"></i> <span id="btn-text">Start Camera</span>`;
                    this.btnCam.classList.replace('from-red-600', 'from-blue-600');
                    this.btnCam.classList.replace('to-pink-600', 'to-cyan-600');
                    this.cubeGroup.visible = false; 
                } else {
                    this.webcamRunning = true;
                    navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then(stream => {
                        this.video.srcObject = stream;
                    });
                    this.btnCam.innerHTML = `<i data-lucide="pause-circle"></i> <span id="btn-text">Pause</span>`;
                    this.btnCam.classList.replace('from-blue-600', 'from-red-600');
                    this.btnCam.classList.replace('to-cyan-600', 'to-pink-600');
                }
                lucide.createIcons();
            },

            refreshLevels: async function() {
                const list = document.getElementById('level-list');
                list.innerHTML = '<div class="text-center text-slate-500"><div class="animate-spin w-4 h-4 border-2 border-white border-t-transparent rounded-full mx-auto"></div></div>';
                try {
                    const colRef = collection(this.db, 'artifacts', this.appId, 'public', 'data', 'spatial_math_levels');
                    const snapshot = await getDocs(colRef);
                    this.levels = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    this.levels.sort((a,b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0));
                    this.renderLevelList();
                } catch (e) {
                    console.error("Firestore Error:", e);
                    // Fallback handled in init, but if manual refresh fails, show error in list
                    if(this.levels.length === 0) this.loadOfflineLevels();
                }
            },

            renderLevelList: function() {
                const list = document.getElementById('level-list');
                list.innerHTML = '';
                if (this.levels.length === 0) { list.innerHTML = '<p class="text-slate-500 text-xs text-center mt-4">No levels found.</p>'; return; }
                this.levels.forEach(lvl => {
                    const div = document.createElement('div');
                    div.className = "level-card bg-slate-900 border border-slate-700 p-3 rounded-lg flex items-center gap-3 cursor-pointer hover:bg-slate-800 transition";
                    div.onclick = () => this.loadLevel(lvl, div);
                    const diffColor = lvl.difficulty === 'Easy' ? 'green-400' : lvl.difficulty === 'Medium' ? 'yellow-400' : 'red-400';
                    div.innerHTML = `<div class="flex-grow min-w-0"><div class="text-sm font-bold text-white truncate">${lvl.name}</div><div class="text-xs text-${diffColor}">${lvl.difficulty}</div></div>`;
                    list.appendChild(div);
                });
                lucide.createIcons();
            },

            loadLevel: function(lvl, cardElement) {
                this.currentLevel = lvl;
                document.getElementById('current-level-name').innerText = lvl.name;
                document.getElementById('current-level-name').classList.remove('text-yellow-400');
                document.querySelectorAll('.level-card').forEach(c => c.classList.remove('active'));
                if(cardElement) cardElement.classList.add('active');
                while(this.cubeGroup.children.length > 0) this.cubeGroup.remove(this.cubeGroup.children[0]);
                if (lvl.blocks) {
                    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity, minZ=Infinity, maxZ=-Infinity;
                    lvl.blocks.forEach(b => {
                        minX = Math.min(minX, b.x); maxX = Math.max(maxX, b.x);
                        minY = Math.min(minY, b.y); maxY = Math.max(maxY, b.y);
                        minZ = Math.min(minZ, b.z); maxZ = Math.max(maxZ, b.z);
                    });
                    const cx = (minX + maxX) / 2; const cy = (minY + maxY) / 2; const cz = (minZ + maxZ) / 2;
                    lvl.blocks.forEach(pos => { const mesh = SpatialUtils.createBlockMesh(pos.x - cx, pos.y - cy, pos.z - cz, false); this.cubeGroup.add(mesh); });
                }
                this.resetCountingState();
                if(window.innerWidth < 768) document.getElementById('level-menu').classList.remove('open');
            },

            resetCountingState: function() {
                this.currentCountStep = 0;
                this.sortedBlocksCache = this.cubeGroup.children.filter(c => c.userData.isBlock);
                this.sortedBlocksCache.sort((a, b) => {
                    if (Math.abs(a.position.y - b.position.y) > 0.1) return a.position.y - b.position.y;
                    if (Math.abs(a.position.z - b.position.z) > 0.1) return a.position.z - b.position.z;
                    return a.position.x - b.position.x;
                });
                this.sortedBlocksCache.forEach(b => this.setBlockColor(b, false));
                if(this.currentLevel) {
                    const txt = document.getElementById('current-level-name');
                    txt.innerText = this.currentLevel.name;
                    txt.classList.remove('text-yellow-400');
                }
            },

            setBlockColor: function(mesh, isHighlight) {
                const mat = Array.isArray(mesh.material) ? mesh.material[0] : mesh.material;
                mat.color.setHex(isHighlight ? SpatialUtils.COLORS.highlight : SpatialUtils.COLORS.block);
                mat.emissive.setHex(isHighlight ? SpatialUtils.COLORS.highlightEmissive : SpatialUtils.COLORS.blockEmissive);
            },

            handleCount: function(dir) {
                if (dir > 0) {
                    if (this.currentCountStep < this.sortedBlocksCache.length) {
                        const block = this.sortedBlocksCache[this.currentCountStep];
                        this.setBlockColor(block, true);
                        const originalScale = block.scale.clone(); block.scale.multiplyScalar(1.2);
                        setTimeout(() => block.scale.copy(originalScale), 150);
                        this.currentCountStep++;
                        if(this.currentCountStep === this.sortedBlocksCache.length) {
                            const txt = document.getElementById('current-level-name');
                            txt.innerText = `Great! All ${this.sortedBlocksCache.length} blocks counted!`; txt.classList.add('text-yellow-400');
                        }
                    }
                } else {
                    if (this.currentCountStep > 0) {
                        this.currentCountStep--;
                        this.setBlockColor(this.sortedBlocksCache[this.currentCountStep], false);
                        const txt = document.getElementById('current-level-name');
                        if(this.currentLevel) txt.innerText = this.currentLevel.name; txt.classList.remove('text-yellow-400');
                    }
                }
            },

            runAI: function() {
                if (!this.handLandmarker || !this.webcamRunning || this.video.paused) return;
                if (this.lastVideoTime !== this.video.currentTime) {
                    this.lastVideoTime = this.video.currentTime;
                    try {
                        const results = this.handLandmarker.detectForVideo(this.video, performance.now());
                        this.ctx2D.clearRect(0, 0, this.canvas2D.width, this.canvas2D.height);
                        if (results.landmarks && results.landmarks.length > 0) {
                            const landmarks = results.landmarks[0];
                            let isRightHand = true;
                            if (results.handedness?.[0]?.[0]) isRightHand = (results.handedness[0][0].categoryName === "Right");
                            
                            const indexTip = landmarks[8]; const indexMCP = landmarks[5];
                            const screenX = (1 - indexTip.x) * 2 - 1; const screenY = -(indexTip.y * 2 - 1);
                            const wrist = landmarks[0]; const middleMCP = landmarks[9];
                            const palmSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                            const zDepth = (palmSize * 15) - 4; 
                            const vector = new THREE.Vector3(screenX, screenY, 0.5);
                            vector.unproject(this.camera);
                            const dir = vector.sub(this.camera.position).normalize();
                            const distance = Math.abs((this.camera.position.z - zDepth) / dir.z);
                            const basePos = this.camera.position.clone().add(dir.multiplyScalar(distance));
                            const vFingerY = new THREE.Vector3((1-indexTip.x)-(1-indexMCP.x), -(indexTip.y-indexMCP.y), -(indexTip.z-indexMCP.z)).normalize();
                            const offsetAmount = 1.2; const offsetVector = vFingerY.clone().multiplyScalar(offsetAmount);
                            this.targetPos.copy(basePos).add(offsetVector); this.targetScale.set(0.7, 0.7, 0.7);
                            
                            const pinkyMCP = landmarks[17];
                            const vPalmX = new THREE.Vector3((1-pinkyMCP.x)-(1-indexMCP.x), -(pinkyMCP.y-indexMCP.y), -(pinkyMCP.z-indexMCP.z)).normalize();
                            let vZ = new THREE.Vector3().crossVectors(vPalmX, vFingerY).normalize(); if (isRightHand) vZ.negate();
                            const vX = new THREE.Vector3().crossVectors(vFingerY, vZ).normalize();
                            const rotationMatrix = new THREE.Matrix4(); rotationMatrix.makeBasis(vX, vFingerY, vZ);
                            this.targetQuaternion.setFromRotationMatrix(rotationMatrix);
                            const yRotation = new THREE.Quaternion(); yRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.manualRotationOffset);
                            this.targetQuaternion.multiply(yRotation);
                            this.cubeGroup.visible = true; 
                        } else { this.targetScale.set(0, 0, 0); }
                    } catch (e) { console.error("Tracking Error:", e); }
                }
            },

            animate: function() {
                this.animationId = requestAnimationFrame(this.animate);
                if (this.webcamRunning) {
                    this.runAI();
                    if(this.cubeGroup) {
                        this.cubeGroup.position.lerp(this.targetPos, this.lerpFactor);
                        this.cubeGroup.scale.lerp(this.targetScale, this.lerpFactor);
                        this.cubeGroup.quaternion.slerp(this.targetQuaternion, this.lerpFactor);
                    }
                }
                if (this.renderer && this.scene && this.camera) this.renderer.render(this.scene, this.camera);
            }
        };

        // ---------------------------------------------------------
        // MAIN ROUTER
        // ---------------------------------------------------------
        window.launchApp = async (appName) => {
            const home = document.getElementById('home-screen');
            const geo = document.getElementById('geometric-app');
            const spatial = document.getElementById('spatial-app');
            home.classList.add('hidden');
            if (appName === 'geometric') {
                geo.classList.remove('hidden'); activeAppName = 'geometric'; await GeometricApp.init();
            } else if (appName === 'spatial') {
                spatial.classList.remove('hidden'); activeAppName = 'spatial'; await SpatialApp.init();
            }
            lucide.createIcons();
        };

        window.exitApp = () => {
            if (activeAppName === 'geometric') { GeometricApp.dispose(); document.getElementById('geometric-app').classList.add('hidden'); }
            else if (activeAppName === 'spatial') { SpatialApp.dispose(); document.getElementById('spatial-app').classList.add('hidden'); }
            document.getElementById('home-screen').classList.remove('hidden');
            activeAppName = null;
        };

        document.addEventListener('touchmove', function(event) { if (event.scale !== 1) { event.preventDefault(); } }, { passive: false });

    </script>
</body>
</html>