<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>รูปคลี่พีระมิดฐานสี่เหลี่ยม (Square Pyramid Net)</title>
    
    <!-- Import Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Import Google Fonts (Sarabun for Thai) -->
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Sarabun', sans-serif; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Custom slider styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px; 
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 2px;
        }
    </style>

    <!-- Import Three.js via CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="bg-gray-50">

    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 z-10 bg-white/90 backdrop-blur-sm p-6 rounded-2xl shadow-lg border border-gray-200 max-w-sm w-full">
        <h1 class="text-2xl font-bold text-gray-800 mb-1">รูปคลี่พีระมิด</h1>
        <p class="text-sm text-gray-500 mb-6">Square Pyramid Net</p>

        <div class="space-y-4">
            <div class="flex justify-between items-center mb-2">
                <span class="text-blue-600 font-semibold">กางออก (Net)</span>
                <span class="text-blue-600 font-semibold">หุบเข้า (Solid)</span>
            </div>
            
            <input type="range" id="foldSlider" min="0" max="100" value="0" class="w-full">
            
            <div class="flex justify-between text-xs text-gray-400 mt-1">
                <span>0%</span>
                <span id="percentDisplay">0%</span>
                <span>100%</span>
            </div>
        </div>

        <div class="mt-6 p-3 bg-blue-50 rounded-lg border border-blue-100">
            <h3 class="font-semibold text-blue-800 text-sm mb-1">คำแนะนำ:</h3>
            <ul class="text-xs text-blue-700 list-disc list-inside space-y-1">
                <li>ลากปุ่มวงกลมเพื่อ หุบ หรือ คลี่ รูปทรง</li>
                <li>คลิกซ้าย + ลาก เพื่อหมุนมุมกล้อง</li>
                <li>เลื่อนลูกกลิ้งเมาส์ เพื่อซูมเข้า-ออก</li>
            </ul>
        </div>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const BASE_SIZE = 4;
        const TRIANGLE_HEIGHT = 4; // Slant height (height of the triangular face)
        const HALF_BASE = BASE_SIZE / 2;
        
        // Calculate max fold angle.
        // The faces start flat (0 deg). They need to rotate UP (90 deg) and then IN.
        // The interior angle with the base is acos(HALF_BASE / TRIANGLE_HEIGHT).
        // The total rotation angle required is PI - interior_angle.
        const MAX_FOLD_ANGLE = Math.PI - Math.acos(HALF_BASE / TRIANGLE_HEIGHT);

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 15, 10);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Grid
        const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0xe5e7eb);
        scene.add(gridHelper);
        
        // --- Materials ---
        const faceMaterial = new THREE.MeshPhongMaterial({
            color: 0x3b82f6, // Blue
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide,
            shininess: 30,
            flatShading: true
        });

        const edgeMaterial = new THREE.LineBasicMaterial({
            color: 0x000000,
            linewidth: 2
        });

        // --- Helper Functions ---

        // Creates a custom triangle mesh defined by 3 vertices (relative to local origin)
        function createCustomTriangle(v1, v2, v3) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                v1.x, v1.y, v1.z,
                v2.x, v2.y, v2.z,
                v3.x, v3.y, v3.z
            ]);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();

            const mesh = new THREE.Mesh(geometry, faceMaterial);
            
            // Add edges
            const edgesGeo = new THREE.EdgesGeometry(geometry);
            const edges = new THREE.LineSegments(edgesGeo, edgeMaterial);
            mesh.add(edges);

            return mesh;
        }

        // --- Build Pyramid ---

        const pyramidGroup = new THREE.Group();
        scene.add(pyramidGroup);

        // 1. Base (Square) on XZ plane
        const baseGeo = new THREE.PlaneGeometry(BASE_SIZE, BASE_SIZE);
        const baseMesh = new THREE.Mesh(baseGeo, faceMaterial);
        baseMesh.rotation.x = -Math.PI / 2; // Lie flat
        // Base Edges
        const baseEdges = new THREE.LineSegments(new THREE.EdgesGeometry(baseGeo), edgeMaterial);
        baseMesh.add(baseEdges);
        pyramidGroup.add(baseMesh);

        // 2. Faces (Pivots)
        // We define each face explicitly to ensure correct initial orientation.
        // Vertices are relative to the pivot point (which is at the edge center).
        
        const pivots = [];

        // --- Right Face (X+) ---
        // Pivot at (2, 0, 0). Hinge along Z-axis.
        // Triangle Base: (0, 0, -2) to (0, 0, 2).
        // Triangle Tip (Unfolded): Points to X+ direction -> (4, 0, 0).
        const pRight = new THREE.Group();
        pRight.position.set(HALF_BASE, 0, 0);
        const meshRight = createCustomTriangle(
            new THREE.Vector3(0, 0, -HALF_BASE), // Corner 1
            new THREE.Vector3(0, 0, HALF_BASE),  // Corner 2
            new THREE.Vector3(TRIANGLE_HEIGHT, 0, 0) // Tip
        );
        pRight.add(meshRight);
        pyramidGroup.add(pRight);
        pivots.push({ group: pRight, axis: 'z', dir: 1 }); // Rotate +Z to lift Up

        // --- Left Face (X-) ---
        // Pivot at (-2, 0, 0). Hinge along Z-axis.
        // Triangle Tip (Unfolded): Points to X- direction -> (-4, 0, 0).
        const pLeft = new THREE.Group();
        pLeft.position.set(-HALF_BASE, 0, 0);
        const meshLeft = createCustomTriangle(
            new THREE.Vector3(0, 0, HALF_BASE),
            new THREE.Vector3(0, 0, -HALF_BASE),
            new THREE.Vector3(-TRIANGLE_HEIGHT, 0, 0)
        );
        pLeft.add(meshLeft);
        pyramidGroup.add(pLeft);
        pivots.push({ group: pLeft, axis: 'z', dir: -1 }); // Rotate -Z to lift Up (CW)

        // --- Back Face (Z-) ---
        // Pivot at (0, 0, -2). Hinge along X-axis.
        // Triangle Tip (Unfolded): Points to Z- direction -> (0, 0, -4).
        const pBack = new THREE.Group();
        pBack.position.set(0, 0, -HALF_BASE);
        const meshBack = createCustomTriangle(
            new THREE.Vector3(HALF_BASE, 0, 0),
            new THREE.Vector3(-HALF_BASE, 0, 0),
            new THREE.Vector3(0, 0, -TRIANGLE_HEIGHT)
        );
        pBack.add(meshBack);
        pyramidGroup.add(pBack);
        pivots.push({ group: pBack, axis: 'x', dir: 1 }); // Rotate +X to lift Up (CCW around X lifts Z- part? Yes right hand rule)

        // --- Front Face (Z+) ---
        // Pivot at (0, 0, 2). Hinge along X-axis.
        // Triangle Tip (Unfolded): Points to Z+ direction -> (0, 0, 4).
        const pFront = new THREE.Group();
        pFront.position.set(0, 0, HALF_BASE);
        const meshFront = createCustomTriangle(
            new THREE.Vector3(-HALF_BASE, 0, 0),
            new THREE.Vector3(HALF_BASE, 0, 0),
            new THREE.Vector3(0, 0, TRIANGLE_HEIGHT)
        );
        pFront.add(meshFront);
        pyramidGroup.add(pFront);
        pivots.push({ group: pFront, axis: 'x', dir: -1 }); // Rotate -X to lift Up

        // --- Animation Logic ---

        const slider = document.getElementById('foldSlider');
        const percentDisplay = document.getElementById('percentDisplay');

        function updateFold() {
            const val = parseInt(slider.value);
            const t = val / 100; // 0 to 1
            
            percentDisplay.textContent = `${val}%`;

            // Calculate current angle
            const currentAngle = t * MAX_FOLD_ANGLE;

            pivots.forEach(p => {
                if (p.axis === 'z') {
                    p.group.rotation.z = currentAngle * p.dir;
                } else {
                    p.group.rotation.x = currentAngle * p.dir;
                }
            });
        }

        slider.addEventListener('input', updateFold);

        // --- Render Loop ---

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize state
        updateFold();
        animate();

    </script>
</body>
</html>