<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Geometry & Nets - Final Fixed Pyramid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Prompt', sans-serif; background-color: #f8fafc; }
        canvas { display: block; width: 100vw; height: 100vh; outline: none; }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
        }
        
        .shape-btn { transition: all 0.2s ease; }
        .shape-btn.active {
            background-color: #3b82f6; color: white;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            transform: translateY(-1px);
        }
        .shape-btn:hover:not(.active) { background-color: #f1f5f9; }

        .toggle-checkbox:checked { right: 0; border-color: #3b82f6; }
        .toggle-checkbox:checked + .toggle-label { background-color: #3b82f6; }
        .toggle-checkbox:checked + .toggle-label:before { transform: translateX(100%); }
        
        #net-control-group { transition: opacity 0.3s ease, transform 0.3s ease; }
        .hidden-control { opacity: 0; pointer-events: none; transform: translateX(20px); }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Prompt:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>
<body>

    <div id="canvas-container" class="w-full h-screen relative">
        <div class="absolute top-6 left-0 w-full text-center pointer-events-none z-10 px-4">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-800 tracking-tight">3D Geometry & Nets</h1>
            <p class="text-slate-500 mt-2 text-sm font-medium">Select a shape and toggle Net Mode</p>
            <div class="mt-4 flex justify-center pointer-events-auto">
                <span id="current-shape-name" class="text-xl font-semibold text-blue-600 glass-panel px-8 py-2 rounded-full min-w-[160px]">
                    Cube
                </span>
            </div>
        </div>

        <div class="absolute right-6 top-1/2 -translate-y-1/2 z-20 flex flex-col gap-4 items-end">
            <div class="glass-panel p-5 rounded-2xl w-48 flex flex-col gap-4">
                <div id="net-control-group" class="flex flex-col gap-2 transition-all duration-300">
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-bold text-slate-700">Net Mode</span>
                        <div class="relative inline-block w-12 h-6 cursor-pointer">
                            <input type="checkbox" id="net-toggle" class="peer sr-only">
                            <div onclick="toggleNetMode()" class="w-11 h-6 bg-slate-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </div>
                    </div>
                    <div class="flex justify-between text-[10px] text-slate-400 font-medium px-1">
                        <span>3D</span>
                        <span>Unfold</span>
                    </div>
                    <hr class="border-slate-100 mt-2">
                </div>
                <div class="flex flex-col gap-2">
                    <span class="text-xs font-medium text-slate-500">Zoom</span>
                    <input type="range" id="zoom-slider" min="10" max="100" value="60" class="w-full h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>
            </div>
            <button onclick="toggleRotation()" id="btn-rotate" class="glass-panel p-3 rounded-full text-blue-600 hover:scale-105 transition-transform" title="Toggle Auto-Rotation">
                <svg id="icon-pause" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                <svg id="icon-play" class="w-6 h-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            </button>
        </div>

        <div class="absolute bottom-8 left-0 w-full px-4 z-10">
            <div class="max-w-4xl mx-auto glass-panel p-2 rounded-2xl">
                <div class="grid grid-cols-6 gap-2">
                    <button onclick="changeShape('cube')" class="shape-btn active rounded-xl py-3 text-sm font-medium" id="btn-cube">Cube</button>
                    <button onclick="changeShape('cuboid')" class="shape-btn rounded-xl py-3 text-sm font-medium text-slate-600" id="btn-cuboid">Cuboid</button>
                    <button onclick="changeShape('cylinder')" class="shape-btn rounded-xl py-3 text-sm font-medium text-slate-600" id="btn-cylinder">Cylinder</button>
                    <button onclick="changeShape('sphere')" class="shape-btn rounded-xl py-3 text-sm font-medium text-slate-600" id="btn-sphere">Sphere</button>
                    <button onclick="changeShape('cone')" class="shape-btn rounded-xl py-3 text-sm font-medium text-slate-600" id="btn-cone">Cone</button>
                    <button onclick="changeShape('pyramid')" class="shape-btn rounded-xl py-3 text-sm font-medium text-slate-600" id="btn-pyramid">Pyramid</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const CONFIG = {
            animSpeed: 0.04,
            colors: {
                mesh: 0x2563eb,
                inner: 0x60a5fa,
                edges: 0xffffff,
                bg: 0xf8fafc
            }
        };

        let scene, camera, renderer, controls;
        let currentSystem = null;
        let isNetMode = false;
        let isRotating = true;
        let currentFold = 0;
        let targetFold = 0;

        const matMain = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.mesh, 
            roughness: 0.5, 
            metalness: 0.1, 
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: 1, 
            polygonOffsetUnits: 1
        });
        
        const matLines = new THREE.LineBasicMaterial({ 
            color: CONFIG.colors.edges, 
            opacity: 0.8, 
            transparent: true,
            linewidth: 2 
        });

        const matGlass = new THREE.MeshPhysicalMaterial({
            color: 0x3b82f6,
            metalness: 0.1,
            roughness: 0.05,
            transmission: 0.9,
            thickness: 0.5,
            transparent: true,
            opacity: 1,
            side: THREE.FrontSide
        });

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 12, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false;
            controls.autoRotateSpeed = 2;
            controls.minDistance = 5;
            controls.maxDistance = 60;

            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            scene.add(sun);
            
            const fill = new THREE.DirectionalLight(0xeef2ff, 0.5);
            fill.position.set(-10, 0, -10);
            scene.add(fill);

            const plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.05 }));
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -2;
            plane.receiveShadow = true;
            scene.add(plane);

            window.addEventListener('resize', onResize);
            document.getElementById('zoom-slider').addEventListener('input', onZoom);

            changeShape('cube');
            animate();
        }

        function createPlate(w, h, d) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, matMain);
            mesh.castShadow = true; mesh.receiveShadow = true;
            const edges = new THREE.EdgesGeometry(geo);
            const lines = new THREE.LineSegments(edges, matLines);
            mesh.add(lines);
            return mesh;
        }

        // --- SHAPE BUILDERS ---

        function buildCubeSystem() {
            const s = 2; const thickness = 0.05;
            const root = new THREE.Group();
            const base = createPlate(s, thickness, s);
            root.add(base);

            function makeSide(x, z, axis, dir) {
                const pivot = new THREE.Group();
                pivot.position.set(x * s/2, 0, z * s/2);
                const mesh = createPlate(axis==='z'?s:thickness, thickness, axis==='x'?s:thickness);
                if (axis === 'x') { mesh.position.set(dir * s/2, 0, 0); mesh.geometry = new THREE.BoxGeometry(s, thickness, s); } 
                else { mesh.position.set(0, 0, dir * s/2); mesh.geometry = new THREE.BoxGeometry(s, thickness, s); }
                pivot.add(mesh);
                return { pivot, mesh };
            }

            const front = makeSide(0, 1, 'z', 1); root.add(front.pivot);
            const back = makeSide(0, -1, 'z', -1); root.add(back.pivot);
            const right = makeSide(1, 0, 'x', 1); root.add(right.pivot);
            const left = makeSide(-1, 0, 'x', -1); root.add(left.pivot);
            const topPivot = new THREE.Group(); topPivot.position.set(0, 0, s); 
            const topMesh = createPlate(s, thickness, s); topMesh.position.set(0, 0, s/2); 
            topPivot.add(topMesh); front.pivot.add(topPivot);

            return {
                root,
                animate: (t) => {
                    const angle = t * (Math.PI/2);
                    front.pivot.rotation.x = -Math.PI/2 + angle; 
                    back.pivot.rotation.x = Math.PI/2 - angle;   
                    right.pivot.rotation.z = Math.PI/2 - angle;  
                    left.pivot.rotation.z = -Math.PI/2 + angle;  
                    topPivot.rotation.x = -Math.PI/2 + angle;
                }
            };
        }

        function buildCuboidSystem() {
            const w = 1.5, h = 1, d = 2.5; const th = 0.05;
            const root = new THREE.Group();
            const base = createPlate(w, th, d); root.add(base);

            const frontP = new THREE.Group(); frontP.position.set(0, 0, d/2);
            const frontM = createPlate(w, th, h); frontM.position.set(0, 0, h/2);
            frontP.add(frontM); root.add(frontP);

            const backP = new THREE.Group(); backP.position.set(0, 0, -d/2);
            const backM = createPlate(w, th, h); backM.position.set(0, 0, -h/2);
            backP.add(backM); root.add(backP);

            const rightP = new THREE.Group(); rightP.position.set(w/2, 0, 0);
            const rightM = createPlate(h, th, d); rightM.position.set(h/2, 0, 0);
            rightP.add(rightM); root.add(rightP);

            const leftP = new THREE.Group(); leftP.position.set(-w/2, 0, 0);
            const leftM = createPlate(h, th, d); leftM.position.set(-h/2, 0, 0);
            leftP.add(leftM); root.add(leftP);

            const topP = new THREE.Group(); topP.position.set(0, 0, h); 
            const topM = createPlate(w, th, d); topM.position.set(0, 0, d/2);
            topP.add(topM); frontP.add(topP);

            return {
                root,
                animate: (t) => {
                    const ang = t * (Math.PI/2);
                    frontP.rotation.x = -Math.PI/2 + ang;
                    backP.rotation.x = Math.PI/2 - ang;
                    rightP.rotation.z = Math.PI/2 - ang;
                    leftP.rotation.z = -Math.PI/2 + ang;
                    topP.rotation.x = -Math.PI/2 + ang;
                }
            };
        }

        // 3. PYRAMID SYSTEM (SEPARATED & FIXED)
        function buildPyramidSystem() {
            const size = 2.5;
            const height = 2.5;
            const half = size / 2;
            const root = new THREE.Group();

            // 1. Base Square
            const baseMesh = createPlate(size, 0.05, size);
            root.add(baseMesh);

            const slantHeight = Math.sqrt(half * half + height * height);
            const liftAngle = Math.atan(height / half);

            // Shape Geometry (Triangle) used for all faces
            const shape = new THREE.Shape();
            // Create a triangle centered at base=0
            shape.moveTo(-half, 0);
            shape.lineTo(half, 0);
            shape.lineTo(0, slantHeight);
            shape.lineTo(-half, 0);
            const triGeo = new THREE.ShapeGeometry(shape);

            // Helper to create a single face assembly
            function createFaceAssembly() {
                const pivot = new THREE.Group();
                const mesh = new THREE.Mesh(triGeo, matMain);
                mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(triGeo), matLines));
                
                // Lay the triangle flat pointing OUT (Local +Y becomes World flat)
                // Default triGeo is XY plane. We rotate -90 X to make it flat on XZ.
                // Local +Y (Height) becomes Local +Z (Outward).
                mesh.rotation.x = -Math.PI/2;
                
                pivot.add(mesh);
                return pivot;
            }

            // --- SEPARATE FACE CONSTRUCTION ---
            
            // 1. FRONT FACE (Z+)
            const frontFace = createFaceAssembly();
            // Position at Z=+half edge
            frontFace.position.set(0, 0, half);
            // No Y rotation needed, it already points +Z
            frontFace.rotation.y = 0; 
            root.add(frontFace);

            // 2. BACK FACE (Z-)
            const backFace = createFaceAssembly();
            // Position at Z=-half edge
            backFace.position.set(0, 0, -half);
            // Rotate Y 180 deg to point -Z
            backFace.rotation.y = Math.PI;
            root.add(backFace);

            // 3. RIGHT FACE (X+)
            const rightFace = createFaceAssembly();
            // Position at X=+half edge
            rightFace.position.set(half, 0, 0);
            // Rotate Y -90 deg to point +X
            rightFace.rotation.y = -Math.PI / 2;
            root.add(rightFace);

            // 4. LEFT FACE (X-)
            const leftFace = createFaceAssembly();
            // Position at X=-half edge
            leftFace.position.set(-half, 0, 0);
            // Rotate Y +90 deg to point -X
            leftFace.rotation.y = Math.PI / 2;
            root.add(leftFace);

            return {
                root,
                animate: (t) => {
                    // t=0 (Closed/3D), t=1 (Open/Net)
                    
                    // Angle Logic: 
                    // To lift UP towards center, we need Negative X rotation 
                    // (Counter-clockwise relative to hinge axis pointing right)
                    const angle = -liftAngle * (1 - t);
                    
                    // --- SEPARATE FACE ANIMATION ---
                    // สั่งแยกกันทีละหน้าตามที่ต้องการครับ
                    
                    frontFace.rotation.x = angle;
                    backFace.rotation.x = angle;
                    rightFace.rotation.x = angle;
                    leftFace.rotation.x = angle;
                }
            };
        }

        // 4. CYLINDER SYSTEM
        function buildCylinderSystem() {
            const r = 1.5;
            const h = 3;
            const segs = 32; 
            const root = new THREE.Group();
            
            const C = 2 * Math.PI * r;
            const panelW = C / segs;
            
            const wrapper = new THREE.Group();
            wrapper.position.y = -h/2;
            root.add(wrapper);

            const centerPanelGeo = new THREE.BoxGeometry(panelW, h, 0.05);
            const centerMesh = new THREE.Mesh(centerPanelGeo, matMain);
            centerMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(centerPanelGeo), matLines));
            wrapper.add(centerMesh);

            const capGeo = new THREE.CircleGeometry(r, 32);
            const topCapPivot = new THREE.Group();
            topCapPivot.position.set(0, h/2, 0); 
            const topCapMesh = new THREE.Mesh(capGeo, matMain);
            topCapMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(capGeo), matLines));
            topCapMesh.position.set(0, r, 0); 
            topCapPivot.add(topCapMesh);
            centerMesh.add(topCapPivot);

            const botCapPivot = new THREE.Group();
            botCapPivot.position.set(0, -h/2, 0);
            const botCapMesh = new THREE.Mesh(capGeo, matMain);
            botCapMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(capGeo), matLines));
            botCapMesh.position.set(0, -r, 0); 
            botCapPivot.add(botCapMesh);
            centerMesh.add(botCapPivot);

            const rightPivots = [];
            
            function createChain(dir, array, limit) {
                for(let i=0; i < limit; i++) {
                    const p = new THREE.Group();
                    p.position.set(dir * panelW/2, 0, 0);
                    
                    const m = new THREE.Mesh(centerPanelGeo, matMain);
                    m.add(new THREE.LineSegments(new THREE.EdgesGeometry(centerPanelGeo), matLines));
                    m.position.set(dir * panelW/2, 0, 0);
                    
                    p.add(m);
                    
                    if(i===0) centerMesh.add(p);
                    else array[i-1].children[0].add(p);
                    
                    array.push(p);
                }
            }
            
            const leftPivots = [];
            createChain(1, rightPivots, segs/2);        
            createChain(-1, leftPivots, segs/2 - 1);    

            return {
                root,
                animate: (t) => {
                    const anglePerSeg = (2 * Math.PI) / segs;
                    wrapper.position.z = -r * (1-t);

                    const jointAngle = anglePerSeg * (1-t);
                    
                    // CURL BACKWARD
                    rightPivots.forEach(p => p.rotation.y = jointAngle); 
                    leftPivots.forEach(p => p.rotation.y = -jointAngle); 

                    const capAngle = (Math.PI/2) * (1-t);
                    
                    // FIXED: Reversed signs to fold Backward (-Z) to match body
                    topCapPivot.rotation.x = -capAngle;  
                    botCapPivot.rotation.x = capAngle;
                }
            };
        }

        function buildConeSystem() {
            const r = 2;
            const h = 3;
            const segs = 36;
            const root = new THREE.Group();

            const slant = Math.sqrt(r*r + h*h);
            const circum = 2 * Math.PI * r;
            const segmentW = circum / segs;
            const slopeAngle = Math.atan(r/h);
            
            const baseGeo = new THREE.CircleGeometry(r, 64);
            const baseMesh = new THREE.Mesh(baseGeo, matMain);
            baseMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(baseGeo), matLines));
            baseMesh.rotation.x = -Math.PI/2;
            root.add(baseMesh);
            
            const shape = new THREE.Shape();
            shape.moveTo(-segmentW/2, 0);
            shape.lineTo(segmentW/2, 0);
            shape.lineTo(0, slant); // Tip
            shape.lineTo(-segmentW/2, 0);
            const triGeo = new THREE.ShapeGeometry(shape);
            
            const anchorPivot = new THREE.Group();
            anchorPivot.position.set(0, 0, -r); 
            baseMesh.add(anchorPivot);

            const anchorMesh = new THREE.Mesh(triGeo, matMain);
            anchorMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(triGeo), matLines));
            anchorMesh.rotation.x = Math.PI/2;
            anchorPivot.add(anchorMesh);

            const rChain = [];
            const lChain = [];
            
            function addLink(dir, list, limit) {
                for(let i=0; i<limit; i++) {
                    const parent = i===0 ? anchorMesh : list[i-1].children[0];
                    const piv = new THREE.Group();
                    
                    piv.position.set(dir * segmentW/2, 0, 0);
                    piv.rotation.z = dir * Math.atan((segmentW/2)/slant);
                    
                    const mesh = new THREE.Mesh(triGeo, matMain);
                    mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(triGeo), matLines));
                    mesh.position.set(-dir*segmentW/2, 0, 0); 
                    
                    piv.add(mesh);
                    parent.add(piv);
                    list.push(piv);
                }
            }
            
            addLink(1, rChain, segs/2);
            addLink(-1, lChain, segs/2 - 1);
            
            return {
                root,
                animate: (t) => {
                    const lift = (Math.PI/2 - slopeAngle) * (1-t);
                    anchorPivot.rotation.x = -lift; 
                    
                    const bend = (Math.PI * 2 * (1 - r/slant) / segs) * (1-t);
                    
                    rChain.forEach(p => {
                        p.rotation.set(0,0,0);
                        p.rotation.z = (Math.atan((segmentW/2)/slant) * 2);
                        p.rotateOnAxis(new THREE.Vector3(0,1,0), -bend); 
                    });
                    
                    lChain.forEach(p => {
                        p.rotation.set(0,0,0);
                        p.rotation.z = -(Math.atan((segmentW/2)/slant) * 2);
                        p.rotateOnAxis(new THREE.Vector3(0,1,0), bend);
                    });
                }
            };
        }

        function buildSphereSystem() {
            const root = new THREE.Group();
            const geo = new THREE.SphereGeometry(2, 64, 64);
            const mesh = new THREE.Mesh(geo, matGlass);
            mesh.castShadow = true; mesh.receiveShadow = true;
            const innerGeo = new THREE.SphereGeometry(1.9, 32, 32);
            const innerMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1 });
            mesh.add(new THREE.Mesh(innerGeo, innerMat));
            root.add(mesh);
            return { root, animate: (t) => {} };
        }

        window.changeShape = function(type) {
            if (currentSystem) scene.remove(currentSystem.root);
            const netGroup = document.getElementById('net-control-group');
            if (type === 'sphere') {
                netGroup.classList.add('hidden-control');
                if(isNetMode) toggleNetMode(); 
            } else {
                netGroup.classList.remove('hidden-control');
            }

            switch(type) {
                case 'cube': currentSystem = buildCubeSystem(); break;
                case 'cuboid': currentSystem = buildCuboidSystem(); break;
                case 'cylinder': currentSystem = buildCylinderSystem(); break;
                case 'cone': currentSystem = buildConeSystem(); break;
                case 'pyramid': currentSystem = buildPyramidSystem(); break;
                case 'sphere': currentSystem = buildSphereSystem(); break;
            }
            
            scene.add(currentSystem.root);
            currentSystem.animate(currentFold);
            
            document.querySelectorAll('.shape-btn').forEach(b => {
                b.classList.remove('active', 'bg-blue-600', 'text-white');
                b.classList.add('text-slate-600');
            });
            const btn = document.getElementById('btn-'+type);
            btn.classList.add('active'); btn.classList.remove('text-slate-600');
            document.getElementById('current-shape-name').innerText = type.charAt(0).toUpperCase() + type.slice(1);
        };
        
        window.toggleNetMode = function() {
            const chk = document.getElementById('net-toggle');
            isNetMode = !isNetMode;
            chk.checked = isNetMode;
            targetFold = isNetMode ? 1 : 0;
            if(isNetMode && isRotating) toggleRotation(); 
        };
        
        window.toggleRotation = function() {
            isRotating = !isRotating;
            controls.autoRotate = isRotating;
            const play = document.getElementById('icon-play');
            const pause = document.getElementById('icon-pause');
            if(isRotating) { play.classList.add('hidden'); pause.classList.remove('hidden'); }
            else { play.classList.remove('hidden'); pause.classList.add('hidden'); }
        };

        function onZoom(e) {
            const val = e.target.value; 
            const dist = 60 - ((val - 10) / 90) * 55;
            const vec = new THREE.Vector3().copy(camera.position).sub(controls.target);
            vec.setLength(dist);
            camera.position.copy(controls.target).add(vec);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (Math.abs(currentFold - targetFold) > 0.001) {
                currentFold += (targetFold - currentFold) * CONFIG.animSpeed;
                if(currentSystem) currentSystem.animate(currentFold);
            } else {
                currentFold = targetFold;
                if(currentSystem) currentSystem.animate(currentFold);
            }
            controls.update();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>